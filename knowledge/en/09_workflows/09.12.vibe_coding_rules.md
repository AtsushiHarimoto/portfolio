# Core Development Lifecycle Guard (BMAD-Lite)

> **Core Methodology**: DocCheck -> Plan -> Approval -> Action -> Verify -> Post-DocCheck
> **Purpose**: Prevent the anti-pattern of "code first, think later"; eliminate development direction drift; ensure every delivery has a traceable evidence chain and rollback guarantees.

---

## 0) Applicable Scope (Always Active)

- These rules apply unconditionally to all task types -- including new feature development, bug fixes, system refactoring, performance optimization, and test coverage improvements.
- If the user explicitly states "discussion only, no code changes," the flow must halt at the `PLAN` phase (or earlier).

---

## 1) Lifecycle Gates (Core Sequence -- No Skipping Allowed)

All modification operations must strictly follow this flow. Cross-phase execution is absolutely prohibited:

### Phase A -- DOC CHECK (Document-First Review)

1. First search the "current target subsystem's" knowledge base and documentation: Are requirements and spec descriptions complete? Are there hidden contradictions or information gaps?
2. If conflicts or gaps are detected:
   - Must use the `ASK` directive to escalate: "What is the specific conflict?", "Which files are directly linked?", and "What source code or execution flows are affected?"
   - Proactively ask the decision maker: "Should this task prioritize fixing documentation, or directly modifying code?"
   - **System default**: Prioritize documentation fixes (Doc First), unless explicit authorization to modify code is given.

> Warning: The DOC CHECK phase is limited to "discovering conflicts" and "listing evidence." Writing code during this phase is strictly prohibited.

### Phase B -- PLAN (Produce a Concrete, Actionable Plan)

A compliant PLAN must include the following structured elements:

- **Core Objective**: A concise summary of the pain point being addressed (1-3 sentences).
- **Impact Scope**: List all modules and files to be modified (with full absolute path prefixes).
- **Side Effects**: Assess potentially affected peripheral features, data structures, or subsystem flows.
- **Risk Disclosure**: List at least 2 potential technical risks with defensive or fallback strategies.
- **Test Strategy**: Commit to at least one verification method (Unit Test / Smoke Test / E2E, or an explicit manual check checklist).
- **Delivery Evidence**: Declare what evidence this iteration will produce for approval (e.g., Log / Stack Trace / Test Report / Diff, or manual confirmation results).

### Phase C -- APPROVAL (Authorization Gate)

- The system must **hard-pause**, awaiting the user's "OK / Approved / Proceed" command before entering the ACTION phase.
- Until authorized, all file modification and overwrite operations are locked (except when the user explicitly states "documentation revision only").

### Phase D -- ACTION (Implementation Within Approved Scope)

- Modifications are only permitted within the file scope defined in the PLAN.
- If new information or a technical dead end invalidates original PLAN assumptions during execution:
  - Must immediately trigger `RETAKE` to halt: Report "which assumption failed," "why it failed," and draft a new PLAN.
  - Return to Phase C and await re-authorization for the new PLAN.

### Phase E -- VERIFY (Mandatory Evidence and Self-Acceptance)

- After every ACTION lands, perform the following checks:
  - Run at least one automated test (unit/smoke/E2E); if no scripts exist, follow a manual check checklist.
  - Compile and output objectively verifiable evidence (e.g., execution logs, trace reports, or manual check result templates).
- If automated checks are impossible due to permission or environment limitations (e.g., no UI control capability):
  - Must produce `manual_checklist.md` containing: prerequisites, operation steps, expected responses, and a standardized failure reporting template.

### Phase F -- POST DOC CHECK (Reverse Spec Alignment)

- After code implementation is complete, perform a mandatory reverse review comparing current code state with original documentation:
  1. Which new behaviors, database fields, or execution flows have converged with the documentation?
  2. Where do gaps between the current system state and documentation descriptions still exist?
- For identified inconsistencies, escalate via `ASK`:
  - "Please advise: for these gaps, should we 'fix the documentation to reflect the code' or 'fix the code to match the documentation'?"
  - **System default**: Prioritize documentation revision (unless instructed otherwise).

---

## 2) Virtual Role-Switching Mechanism (Perspective Shift)

Within a single conversation lifecycle, the AI must cycle through these perspectives in order (regardless of its system persona setting):

- **Reviewer**: Execute DOC CHECK or bug investigation (limited to evidence collection and conflict identification).
- **Designer**: Write the PLAN (including test and deliverable targets).
- **Implementer**: Execute the ACTION phase (only authorized scope changes).
- **Verifier**: Execute VERIFY (acceptance testing and evidence collection).
- **Auditor**: Execute POST DOC CHECK (inventory inconsistencies and propose fixes).

---

## 3) Session Drift Guard

- If the same task or issue goes back and forth for 3 rounds without converging on a solution: The AI must proactively trigger `RETAKE`, recommending scope reduction or task decomposition.
- For any spec-undefined blind spots: Use the `ASK` directive to list all concerns at once. Fragmented, piecemeal questions are prohibited.

---

## 4) Standardized Output Format and Communication Protocol

- All responses must use Traditional Chinese (mainland Chinese technical vocabulary is acceptable), maintaining precise, professional, and concise language.
- Response headers must include key status prefixes (aligned with the core communication protocol):
  - `DOC:` Documentation alignment progress / conflict check report (can be combined with BG phase).
  - `BG:` Root cause investigation results / evidence listing.
  - `PLAN:` Implementation plans and proposals.
  - `ASK:` Choices and pending decisions for the decision maker.
  - `RETAKE:` Self-correction / withdrawal of previous direction.
  - `ACTION:` Implementation trace declaration.
  - `VERIFY:` Test execution results and objective evidence package.
  - `POSTDOC:` Reverse review results and documentation diff.

---

## 5) AI Agent Deployment Guide

### 5.1 Configuration in Antigravity

1. Save the above clauses as: `./.agent/rules/40_bmad_lifecycle_guard.md`.
2. Via Antigravity's Rules management interface, set this rule to "Always On."
3. When starting a new collaboration session, strongly recommend using "Planning mode" to ensure the AI produces a PLAN first, avoiding premature code modification.
4. Core mantra: `Execute DOC CHECK -> Present PLAN -> Await approval before ACTION -> Must VERIFY and POSTDOC before closing`.

### 5.2 Lightweight Deployment in Codex and Other Headless Tools

Since some tools cannot persistently load specific config files, inject the following "minimal protection prompt" at the top of each new session:

> **SESSION RULES (Inviolable Primary Directive)**
>
> - Execute DOC CHECK (inventory current sub-project docs descriptions and potential conflicts).
> - Produce a compliant PLAN (must include impact scope, risks, test strategy, and expected deliverables).
> - Pause and await `OK` approval before launching ACTION (strictly limited to approved scope).
> - After ACTION, must execute VERIFY (unit/smoke/E2E test, or provide manual checklist) and produce evidence.
> - In the closing phase, execute POSTDOC: truthfully report gaps between code state and documentation, and ask "should we fix the docs or the code?"
> - This session uses Traditional Chinese (mainland vocabulary acceptable), maintaining professionalism and conciseness.

### 5.3 Token-Efficient Interaction Cadence

Recommended concise feedback loop to prevent AI over-divergence:

1. **Issue task**:
   - Example: `DOC+PLAN: Please implement <feature> in <target module> (scope = xxx). Check for doc conflicts first, then present a plan.`
2. **AI submits initial draft and failsafe queries (DOC CHECK + PLAN)**.
3. **Human authorizes**: If no objections, simply reply `OK`.
4. **AI proceeds with implementation (ACTION)**.
5. **AI submits closure evidence**: Auto-completes `VERIFY (with evidence)` + `POSTDOC (documentation diff report)`.

---

## 6) UI Visual and Experience Fidelity Guard

When handling frontend UI tasks, the Agent is **absolutely prohibited from injecting subjective visual aesthetics or design decisions**. In the Moyin ecosystem, any unauthorized "proactive optimization" is classified as a "quality incident."

### 6.1 No Doc, No UI (Black-and-White Constraint)

- Any addition or removal of visual elements is legal only if documented in black and white in the Design Spec.
- **"Self-appointed perfection is the greatest enemy of precise specifications"**: Even if the AI determines a change would make the interface more elegant, if the documentation doesn't mention it, it constitutes an unauthorized action and is unconditionally prohibited.

### 6.2 Mandatory Design Double-Check

- **Pre-Action**: The PLAN must specify which UI components will be affected and reference the corresponding `2.4.x` design specification document section anchors.
- **Post-Action**: After ACTION closure, the AI must self-compare the final UI output against the original design spec. If extra visual elements not in the spec are found, the system must unconditionally perform a Rollback.

### 6.3 Preventing "Blind UI Overhaul" Hallucinations

- Unauthorized additions of unreviewed icons, emojis, effects/animations, or interference with global CSS Variables in `theme.css` are strictly prohibited.
- If current `theme.css` variables are insufficient, the AI is forbidden from "intuitively" creating new variables. Instead, use `ASK` to request authorization from the frontend architecture team.

### 6.4 Agile Consistency Baseline

- While advocating rapid iteration, all operations must be built on the premise of "absolute spec consistency." Agents must deeply understand: for Japanese-market projects, global experience and visual "consistency and gravitas" far outweigh "flashy variety" in any single feature.

> [!CAUTION] Stern Warning
> If the Agent again triggers a "Proactive Design" hallucination (e.g., unauthorized addition of extra icons), the system user reserves the right to invoke the "Super Override Command." The Agent must immediately suspend all physical file write operations and restart from the DOC CHECK phase from scratch.

---

## 7) Component and Style Resource Reuse Standards

When implementing frontend interfaces, the Agent **must prioritize existing shared components and styles**, rigorously preventing "reinventing the wheel" code redundancy.

### 7.1 Component Lookup Priority Order

Before declaring any new UI entity or DOM structure, inventory in this sequence:

1. Check `components/ui/*` (global shared UI component library)
2. Check `components/*.vue` (page-level shared components)
3. Check `theme.css` (CSS visual variables and Design Token library)

If an existing component meets the need, **it must be reused**. If a new component is deemed necessary, an `ASK` evaluation request must be submitted before implementation.

### 7.2 Mandatory Component Mapping Table

| Requirement Scenario   | Mandatory/Preferred                | Prohibited Implementation                     |
| :--------------------- | :--------------------------------- | :--------------------------------------------- |
| Button controls        | `UiButton`                         | Native `<button>` or custom `<div>`            |
| Vector icons           | `Icon`                             | Native `<i>`, `<svg>`, `<img>` tags            |
| Modal overlays         | `ModalDialog`                      | Hand-coded overlays or native `<dialog>`       |
| Toast notifications    | `window.$toast.show()`             | Native `alert()` or hand-coded toast UI        |
| Confirmation dialogs   | `window.$dialog.open()`            | Native `confirm()` or hand-coded dialog UI     |
| Scrollable regions     | `ScrollBox`                        | Native `overflow` + hand-coded hidden CSS      |
| Bottom navigation      | `BottomMenu`                       | Hand-coded navigation bars                     |

### 7.3 Global CSS Token Enforcement

| Visual Property Category | Mandatory System Variable                     | Prohibited Hardcode                             |
| :----------------------- | :-------------------------------------------- | :---------------------------------------------- |
| Color                    | `var(--ui-primary)`, `var(--ui-text)`          | Absolute codes `#ff0000`, `pink`, `rgb()`       |
| Box Shadow               | `var(--ui-shadow-soft)`                        | Hand-coded `0 2px 4px rgba()`                   |
| Border Radius            | `var(--ui-radius-md)`                          | Absolute pixel values `8px`, `20px`             |
| Z-index                  | `var(--ui-z-modal)`                            | Magic numbers `999`, `9999`                     |

### 7.4 Violation Response Protocol

If post-audit reveals the Agent failed to reuse system components or tokens:

1. The Agent must immediately stop all other code work.
2. Self-report the oversight via `RETAKE` and list the planned fix (variables/components).
3. Refactor the non-compliant code to use global variables and standard library calls.
4. Archive this mistake and lesson in the `insights/` directory to prevent recurrence.
