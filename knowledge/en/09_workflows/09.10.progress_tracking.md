# Large Task Progress Tracking Mechanism

> **Type**: Workflow / Tooling Techniques
> **Date**: 2026-01-11
> **Source**: Conversation - Issue Management System Setup

---

## Summary

For tasks with high token consumption or spanning many files, this mechanism implements automated scale assessment, batch execution strategies, and real-time progress tracking to prevent token overflow and task runaway risks.

---

## Background

### Historical Pain Points

When executing large-scale tasks, these bottlenecks frequently occur:

1. **Token Overflow**: A single execution covers too many files, exceeding the context token limit.
2. **Progress Blind Spot**: Unable to observe task progress in real time.
3. **Low Fault Tolerance**: Mid-task crashes often require starting over from scratch.
4. **Unpredictable Duration**: Lack of quantitative metrics to estimate time to completion.

### Requirements

The user explicitly requested:

> "When executing global tasks, if the system estimates massive token consumption, it must proactively activate a batching mechanism and periodically update progress in a separate Markdown file."

---

## Detailed Design

### Automated Scale Assessment

Before task launch, the AI must perform a mandatory scale pre-assessment:

```typescript
interface TaskEstimate {
  type: "small" | "medium" | "large";
  estimatedFiles: number;
  estimatedTokens: number;
  suggestedBatches: number;
}
```

**Assessment Criteria**:

- **Small**: <= 5 files, estimated < 20k tokens -> Single-pass execution.
- **Medium**: 6-15 files, estimated 20k-50k tokens -> Optional batching.
- **Large**: > 15 files, estimated > 50k tokens -> **Mandatory batching strongly recommended**.

**Assessment Report Output Example**:

```
Task Scale Assessment Report

Task type: Feature module refactoring
Expected files affected: 20
Estimated token consumption: ~80k
Recommended execution strategy: Batch Processing

Large task detected. Recommended to split into 4 independent batches.
Enable progress tracker? (y/n)
```

---

### Progress Tracker File Structure

**File Storage Path**: `workspace/progress/{TASK_ID}_1.progress.md`

**Template**:

```markdown
# {Task Name} - Execution Progress Tracker

## Overall Status

- Current state: In Progress
- Progress: 25% (1/4 batches completed)
- Start time: 2026-01-11 02:00
- Estimated completion: 2026-01-11 04:30

## Batch Details

### Batch 1/4 - Core Foundation Modules (Completed)

- Files affected: Button.vue, Input.vue, Select.vue
- Token consumption: ~18k
- Actual duration: 15 minutes
- Status: Completed

### Batch 2/4 - Layout Components (In Progress)

- Files affected: Layout.vue, Grid.vue, Flex.vue
- Token consumption: ~20k
- Status: In Progress (2/3 files completed)

### Batch 3/4 - Form Interaction Components (Queued)

- Files affected: Form.vue, FormItem.vue, Checkbox.vue
- Token consumption: ~22k
- Status: Pending

### Batch 4/4 - Documentation and Knowledge Base Alignment (Queued)

- Files affected: README.md, CHANGELOG.md, docs/
- Token consumption: ~20k
- Status: Pending
```

---

### Batching Strategy

#### Guiding Principles

1. **Module Cohesion**: Strongly related and dependent files must be grouped in the same batch.
2. **Load Balancing**: Token consumption per batch should be as close to the average as possible to avoid single-batch overload.
3. **Dependency Ordering**: Strictly follow "core foundation -> dependent modules -> edge applications" implementation order.
4. **Docs Last**: Documentation and spec updates should only occur in the final batch after all code logic is complete.

#### Batch Planning Example

**Target Task**: UI system full refactoring (20 files, ~80k tokens estimated)

```
Batch 1 (Core Foundation Layer):
  - Target: Button.vue, Input.vue, Select.vue
  - Load: ~18k
  - Rationale: Lowest-level system components; absolute dependency of upper layers.

Batch 2 (Layout Layer):
  - Target: Layout.vue, Grid.vue, Flex.vue
  - Load: ~20k
  - Rationale: Application layer inheriting from core components.

Batch 3 (Form Interaction Layer):
  - Target: Form.vue, FormItem.vue, Checkbox.vue, Radio.vue
  - Load: ~22k
  - Rationale: Most complex frontend interaction layer, dependent on the first two layers.

Batch 4 (Documentation Alignment Layer):
  - Target: README.md, CHANGELOG.md, docs/components/
  - Load: ~20k
  - Rationale: Knowledge base refresh after code changes are finalized.
```

---

### Real-Time Feedback Update Mechanism

At the end of each batch, the system must automatically update the progress file:

1. **Status Indicator Transition**: Pending -> In Progress -> Completed.
2. **Percentage Recalculation**: Precisely compute overall percentage based on completed batches.
3. **Time Audit**: Accurately record physical duration of each batch.
4. **Time Convergence Prediction**: Dynamically calibrate estimated completion time based on completed batch average throughput.

### Task Closure Procedure

After all batches are declared complete:

1. Update the progress file overall status to "Completed."
2. Seal the progress file and move it to the designated ISSUE archive folder or associated Scope knowledge base.
3. Ensure the main task `README.md` references and links to this progress tracker file for future traceability.

---

## Workflow Integration Points

### Entry: `/inbox`

```
User issues /inbox command -> Triggers scale assessment -> If assessed as Large -> Mandatory prompt to enable batched progress tracking
```

### Entry: `/bg` (Bug Deep Dive)

```
User issues /bg command -> Selects Deep Dive mode -> System determines large file scope involved -> Prompts to enable progress tracking
```

### Entry: `/dev` (Core Development)

```
User issues /dev command -> Selects Feature/Refactor push -> Triggers scale assessment -> Assessed as Large -> Auto-enables progress tracking safety net
```

---

## Practical Examples

### Example 1: Cross-Module UI System Refactoring

**Trigger Input**:

```
@inbox

Target: Please thoroughly refactor the entire UI component library to align with the latest Design Tokens. Begin.
```

**System Response and Progression**:

1. Assessment: Large (20 files, ~80k tokens estimated).
2. System recommends: Split into 4 batch execution matrix.
3. User authorizes: Inputs `y`.
4. Progress tracker created: `workspace/progress/ISSUE-042_1.progress.md`.
5. Batch 1 (core foundation) begins.
6. Incremental updates: 25% -> 50% -> 75% -> 100%.
7. Closure: Progress record archived to ISSUE directory.

### Example 2: Bug Deep Dive and Large-Scale Fix

**Trigger Input**:

```
@bg

Observed behavior: After loading a save file, the game state machine fails to restore consistently.
Strategy: Mode 3 (Deep Dive)
```

**System Response and Progression**:

1. Evidence chain established and root cause analyzed.
2. Approximately 10 core modules identified as involved.
3. Assessment: Medium-Large (~55k tokens).
4. System recommends: Asks whether to enable progress tracker; user inputs `y`.
5. Planned as 3 batch repair waves.
6. Coding fix begins with real-time progress file updates.

---

## Best-Fit Scenarios

- Large-scale foundational refactoring (> 15 files).
- System-level bugs with high propagation risk.
- Large logic module or framework migrations.
- Batch knowledge base or API documentation overhauls.
- Any epic-scale task estimated to approach or exceed the 50k token threshold.

---

## Core Advantages

1. **Controllability**: Batch execution prevents token overflow causing systemic memory loss and crashes.
2. **Visibility**: Gives users a real-time global view, eliminating "black box" anxiety.
3. **Recoverability**: If a specific batch fails, only that batch needs to be reset without affecting prior completed work.
4. **Predictability**: Dynamic completion time estimation provides project managers with accurate time expectations.
5. **Traceability**: Log trail files serve as critical references for future optimization or debugging investigations.

---

## Practical Precautions

- **Per-batch load limit**: Ensure single-batch token consumption stays within the 30k safety threshold.
- **Dependency order is irreversible**: Never process application layers before foundation layers.
- **Write immediately**: At each batch checkpoint, immediately commit status to the file system.
- **Archive discipline**: Tasks must not decay in `workspace/progress/`; archive-move is mandatory upon completion.
- **Minimize interruption**: Only activate when the Large threshold is triggered, to avoid adding unnecessary system dialog overhead.

---

## Related Resources

- [Inbox Workflow Guide](../09_workflows/inbox_workflow.md)
- [Bug Deep Dive Operations Guide](../09_workflows/bug_investigation.md)
- [Core Development Workflow Standard](../09_workflows/dev_workflow.md)
- [Issue Management System Guide](09.6.issue_management_system.md)

---

_This document was auto-generated by the modular maintenance system on 2026-01-11_
