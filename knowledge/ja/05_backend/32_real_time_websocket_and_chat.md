# 32. HTTP の呪縛を解き放つ：持続的ロングコネクションと WebSocket (Real-Time Comm)

> **種類**: クロスプラットフォーム・リアルタイム通信の入門
> **重点**: HTTP の「一問一答」という一方向のポーリングの束縛に別れを告げます。コミュニケーションソフトウェア (Discord や Line など) や高頻度取引のダッシュボードの背後にある魂のテクノロジー：**WebSocket** と、100 万の接続クラスターにおいて最も厄介な「メッセージルーティング (Pub/Sub)」問題の解決方法を深く分析します。

---

## 序：HTTP とは一度話したら強制的に切られる電話である

あなたが Web 上のショッピングモールを作り、フロントエンドが `GET /products` を送信すると、バックエンドは JSON の束を返し、その後 HTTP プロトコルは容赦なく底層の TCP 接続を「パキッ」と切り捨てます。
これは、バックエンドが次の顧客にサービスを提供するためにリソースを解放する (ステートレス Stateless) という偉大な設計です。

**しかし、もしあなたのアプリケーションが「リアルタイムのグループチャットルーム」であった場合、この設計は惨劇となります。**

### ☠️ 愚かな解決策：ポーリング (Short/Long Polling)

A がメッセージを送信した時、B が「すぐに見られる」ようにするために、初級開発者は `setInterval` を書き、このスマホに毎秒 1 回 `GET /new-message` をサーバーに送信して問い合わせを作らせます。

- **結果**：1 万人のユーザーがオンラインでぼーっとしているだけで、サーバーは 1 秒間に 1 万回もの高価な HTTP ハンドシェイク (確立と破棄のための 3 ウェイハンドシェイク) を無駄に耐えなければなりません。CPU とネットワーク帯域幅は、海のような「新着メッセージなし」の空のパケットによって瞬く間に搾り取られます。

---

## 1. 救世主降臨：WebSocket 双方向持続的接続

「せっかく電話が繋がったのだから、ホットラインを切らずにそのままにしておこう！」—— WebSocket の覇気あふれるオープニングです。

1. **プロトコルのアップグレード (Protocol Upgrade)**：
   フロントエンドが初めて接続する際、依然として一般的な HTTP リクエストを送信しますが、ヘッダー (Header) の中にプロポーズの指輪をこっそり忍ばせます：`Connection: Upgrade`、`Upgrade: websocket`。
2. **全二重通信 (Full-Duplex)**：
   サーバーが頷いて同意 (`101 Switching Protocols`) した後、**HTTP プロトコルは退場し、この一方向の水道管は瞬時に双方向の超高速真空管へと進化します**。
   - サーバーはもはやフロントエンドがデータを要求するのを「待つ必要」がありません。サーバーバックエンドの AI が画像の生成を終えたら、能動的に画像をブラウザに投げつける (サーバープッシュ) ことができます！
   - TCP の煩雑なハンドシェイクのオーバーヘッドは最初の 1 回しか発生しません。その後の毎回のチャットメッセージの伝送負荷は、0 Byte に近いパケットの骨組みとなります。(毎回の数百 Bytes に及ぶ肥大化した HTTP ヘッダーが節約されます)。

---

## 2. 残酷なクラスター地獄：WebSocket が複数台のマシンで直面する死

大学のレポートであれば、Node.js の `socket.io` を使ってグローバル配列を書き、50 個の `ClientConnection` を保存しておけば、楽しくブロードキャスト (`io.broadcast`) することができます。

しかし、ByteByteGo のエンタープライズレベルのマイクロサービスアーキテクチャにおいて、もし 3 台のチャットサーバー (Server A, B, C) があるとしたら：
ユーザー `甲` が Server A に接続しました。
ユーザー `乙` が Server C に接続しました。
この時、`甲` が `乙` にメッセージを送信します。Server A は自分のメモリ配列の中を狂ったように探し回りますが、**`乙` が見つかりません！** そしてこのメッセージは容赦なく破棄され、甲と乙の次元の壁は完全に阻絶されてしまいます。これがロードバランサークラスター環境での Stateful (状態を持つ) 接続の恐ろしい急所です。

### 📡 解決策：Pub/Sub バックエンド放送局 (Redis の降臨)

Server A を孤島で一人で人探しをさせては絶対にダメです。解決策は、グローバルなゴシップセンター (Redis Pub/Sub や軽量版 Kafka など) を導入することです。

1. **チャンネルの登録**：Server C が起動する時、こっそりと Redis にこう伝えます：「`#チャットルーム1` に送られるすべてのメッセージを、私にもコピーして送ってください。」
2. **境界を越える魔法**：Server A が `甲` からのメッセージを受け取った時、自分で処理するのではなく、そのメッセージを直接大声で Redis 内の `#チャットルーム1` チャンネルに向けて投げつけます (ブロードキャスト)。
3. **正確な配信**：購読している Server C が Redis からこの爆弾発言を聞きつけ、自分の配下にちょうど `乙` の WebSocket パイプラインが繋がっていることに気づき、大至急パイプラインを通じて「プッシュ (Push)」します！
   こうすることで、10 万人のプレイヤーがどのホストに散らばっていようとも、隔たりを越えてミリ秒の間にリアルタイムの集団戦を繰り広げることができるのです。

---

## 💡 Vibecoding 指令

AI アーキテクトにリアルタイムのインタラクションを備えた AI コラボレーションボード、またはゲームエンジン通信の構築を命じる際、これらの底層テクノロジースタックは不可欠な指令となります：

> 🗣️ `「私たちのこの【AI 対話と共同黒板マイクロサービス】はミリ秒レベルの描画同期を達成することを求めています。フロントエンドが setInterval の Long/Short Polling を使って私の Node.js のスレッドを浪費することは絶対に許可しません！フロントエンドを RxJS のイベントストリームに接続し、バックエンドは必ず【WebSocket (socket.io / ws など)】のロングコネクションにアップグレードしてオンにしてください！さらに、バックエンドは Kubernetes の複数のレプリカをデプロイしているため、あるプレイヤーが別パーティションに接続しているプレイヤーの筆跡ブロードキャストを受け取れない事態を防ぐために、ノード間のメッセージ中継器として Node.js に手動で【Redis-Adapter または Pub/Sub メカニズム】を追加しなければなりません！」`
