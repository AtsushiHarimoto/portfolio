# 22. マイクロサービスの一貫性の危機：分散トランザクションと Saga 補償パターン (Distributed Transactions)

> **種類**: 分散システムとバックエンドアーキテクチャ概論
> **重点**: システムが巨大なモノリス (Monolith) からマイクロサービス (Microservices) へと分裂する時、過去のデータベースの「全部成功するか、全部失敗するか」という ACID の神話がいかにして崩壊するかを探求します。ByteByteGo が強く推奨する非同期一貫性の解決策である、Saga パターンとトランザクショナル・アウトボックス (Transactional Outbox) パターンを深く解析します。

---

## 序：「データベース」が孤島に切り刻まれた時

伝統的なモノリシックアーキテクチャでは、もしプレイヤーがチェックアウトして仮想アイテムを購入した場合、データベース接続 (MySQLなど) を 1 つ開き、次のように指令を出すだけで済みます：
`BEGIN; プレイヤーのコインを減らす(); バックパックにアイテムを追加する(); COMMIT;`。
その中間の 1 行でもクラッシュしてエラーが投げられた場合、データベースは堂々と `ROLLBACK` をトリガーし、まるで何もなかったかのように、コインも減らず、アイテムも付与されません。これが私たちのリレーショナルデータベースに対する絶大な信頼の礎です (ACID)。

しかし、システムが巨大化し、**マイクロサービスアーキテクチャ**へと進化した後、このロジックは完全に機能しなくなります：
「コインシステム」はあるチームによって管理され、背後には PostgreSQL があります。
「バックパックシステム」は別のチームによって管理され、背後には MongoDB があります。
**この 2 つのデータベースは決して互いに交わることはなく、協調して `ROLLBACK` を実行することは根本的に不可能です。これがマイクロサービスにおける最も凶悪な痛点、「分散トランザクション (Distributed Transactions)」を引き起こします**。万が一、コインシステムで引き落としが成功したのに、アイテムを付与するためにバックパックシステムを呼び出す際にネットワーク切断に遭遇した場合、プレイヤーは「お金はなくなったのに、アイテムももらえない」という極度の怒りに陥ることになります。

---

## 1. 悲観的独裁者の末路：2PC (2 フェーズコミット)

初期の頃、分散トランザクションを解決するために、エンジニアは `Two-Phase Commit (2PC)` を発明しました。
これには「グローバルコーディネーター (Global Coordinator)」が立ち上がり、コインデータベースとバックパックデータベースの両方を同時にロックする必要があります：

- **フェーズ 1 (Prepare)**：コーディネーターは双方に「お金の引き落としとアイテムの付与の準備はできたか？誰も動くな！」と尋ねます (この時、両方のデータベースは厳重にロックされます)。
- **フェーズ 2 (Commit)**：双方が OK と返答した後、コーディネーターはようやく最終指令「よし、一緒に書き込め！」を下します。

❌ **致命的な弱点**：これは非常に重いブロッキングの「同期的足枷」です。準備段階では、他者の改ざんを防ぐためにデータベースのリソースが完全にロックされます。これは、2PC を採用した途端、高並行システム全体のスループット (Throughput) が崖から落ちるような雪崩を引き起こし、インターネット規模の膨大な接続には全く対応できなくなることを意味します。

---

## 2. マイクロサービスの新たな生存法則：Saga パターン (長期トランザクション補償パターン)

2PC のロックのデッドロックを打破するため、高スループットを受け入れる現代のアーキテクチャ (ByteByteGoが推奨するものなど) は、「絶対に同時に起こる」という幻想を捨て、**「結果整合性 (Eventual Consistency)」** を追求するように変化しました。

Saga の精神は：**グローバルなロックは必要ありません。部門をまたぐ大きなトランザクションを、完全に細かいローカルなトランザクションに分割します。もし前の小さなトランザクションが成功し、後ろのトランザクションが不幸にも失敗した場合、私たちはロールバック (Rollback) を行うのではなく、「補償アクション (Compensating Actions)」をトリガーして過去の過ちを修復します。**

### 🧩 シナリオ演習：Moyin の生成ポイントモール

ユーザーが専用の AI キャラクターをサブスクライブするために 50 ポイントを消費するとします。これには 3 つのローカルトランザクションタスクが含まれます：
`[サービス A：ポイントの引き落とし] ➡️ [サービス B：キャラクター権限のロック解除] ➡️ [サービス C：ウェルカムメールの送信]`

**成功シナリオ**：Aが成功 ➡️ Bに通知。Bが成功 ➡️ Cに通知。Cが成功し、チェーン全体 (Saga) が円満に終幕します。

**失敗補償シナリオ (Saga 返金メカニズム)**：

1. **[サービス A]** でポイントの引き落としが成功。
2. **[サービス B]** でキャラクターのロックを解除しようとした際、そのキャラクターがすでに提供終了になっていることを発見し、エラーが発生 (Failed)。
3. この時、Saga コーディネーター (あるいはサービス B 自身) が警報を発し、緊急に**逆方向の補償チェーンである「返金部隊」**を起動します：
   - 即座に **[サービス A]** に対して「補償トランザクション (Compensating Transaction)` の指令を出します：`そのプレイヤーの 50 ポイントを返還し、失敗の理由を添付せよ。`

Saga はデータベースロックの束縛を大幅に解放し、各システムを飛ぶように高速で実行させますが、その代償としてエンジニアはあらゆる「書き込みアクション」に対して、専用の「取り消し/返金アクション」を別途準備しなければなりません。

---

## 3. メッセージの絶対的な到達を保障する：トランザクショナル・アウトボックス (Transactional Outbox)

Saga の中では、マイクロサービス A がお金の引き落としを完了した後、マイクロサービス B に「メッセージ (Event) を送信」して通知しなければなりません。しかし、もし引き落としが成功した直後、サーバーがメッセージを送信する前に突然停電してしまったらどうなるでしょうか？ これが有名な「二重書き込みの一貫性の問題 (Dual-Write Problem)」です。

メッセージの紛失を防ぐための業界標準は **アウトボックス・パターン (Outbox Pattern)** です：
マイクロサービス A はメッセージを直接外部に投げることはなく、自身のデータベース内に `Outbox (送信トレイ)` という新しいテーブルを追加します。

1. **同じローカルデータベーストランザクション (Local Transaction)** 内で、次を実行します：`ポイントの引き落とし(); INSERT INTO Outbox (イベント：B にキャラクターのロック解除を通知); COMMIT;` (これにより、両者が絶対に運命を共にすることが保証されます)。
2. 別の独立したバックグラウンドプログラム (Message Relay) を起動し、`Outbox` テーブルを必死に監視し続けます。新しい手紙を発見したら、何百回再試行しようとも、必ずそれを送信機 (Kafka や RabbitMQ など) に投げ込みます。無事に送信が完了した後で初めて、`Outbox` の記録に線を引いて消し込みます。
   これにより、防弾レベルのメッセージ伝達の保証が達成されます。

---

## 💡 Vibecoding 指令

AI アーキテクトに巨大な e コマースやポイントチェックアウトのロジックの分割を命じる場合は、必ず次の呪文で縛りをかけてください：

> 🗣️ `「この注文の作成と在庫の引き下げの処理は、ドメインをまたぐマイクロサービスに関与します。従来の DB トランザクションによるグローバルなバインディングや 2PC デッドロックを試みることは絶対に禁止します。Saga パターンを適用してください！私たちは高スループットの結果整合性を受け入れます。もし在庫の引き下げが失敗した場合は、必ず対等な事前返金サービス (Compensating Action) のトリガーを確保し、全行程で Outbox パターンを組み合わせて通知メッセージをキューに投げ込み、データの一滴すら絶対に漏らさないようにしてください！」`
