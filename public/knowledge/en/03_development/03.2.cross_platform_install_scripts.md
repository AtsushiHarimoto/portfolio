# 03.2. Cross-Platform Install Scripts

> **Type**: DevOps best practices  
> **Focus**: Describe how to craft resilient, user-friendly automation scripts (`install.sh` + `install.ps1`) so cross-OS onboarding is one command, not hours of manual setup.

---

## Summary

Public OSS and internal tools often stumble at ‚Äúenvironment bootstrapping across macOS/Linux/Windows.‚Äù Missing toolchains or manual dependency compilation frustrate newcomers before they even write code. Well-written dual-platform scripts turn multi-hour diagnosis into a single command, delivering a frictionless Rust or Python onboarding experience.

---

## Design principles

1. **Idempotent detection**: Probe the PATH and installed versions before any action. If the tool already exists, skip it to avoid duplicate installs.  
2. **Defensive programming**: On unrecoverable failures (download breakage, compile error), fail fast‚Äîdo not let the system advance with partial state.  
3. **Clear visual feedback**: Replace monochrome logs with ANSI colors (Bash) or PowerShell formatting so informational, warning, and fatal messages stand apart.  
4. **Interactive confirmations**: For privileged writes or multi-gigabyte downloads, prompt the user with a yes/no confirmation instead of proceeding silently.

---

## Chapter 1: macOS/Linux (`install.sh`)

Structure the Bash script around `set -e`.

```bash
#!/bin/bash
set -e

GREEN='\033[0;32m'; YELLOW='\033[1;33m'; NC='\033[0m'

command_exists() { command -v "$1" >/dev/null 2>&1; }

print_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
print_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }

check_rust_toolchain() {
  echo ">> Verifying Rust toolchain..."
  if command_exists rustc && command_exists cargo; then
    RUST_VERSION=$(rustc --version | awk '{print $2}')
    print_success "Rust already installed: $RUST_VERSION"
    return 0
  else
    print_warning "rustc/cargo not found."
    return 1
  fi
}

install_rust_interactive() {
  read -p "Rust is missing. Download and install now? (y/n): " -n 1 -r
  echo ""
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    source "$HOME/.cargo/env"
    print_success "Rust installation complete."
  fi
}

main() {
  if ! check_rust_toolchain; then
    install_rust_interactive
  fi
  cargo build --release
}

main
```

---

## Chapter 2: Windows (`install.ps1`)

PowerShell scripts rely on `$ErrorActionPreference` for defensive behavior.

```powershell
$ErrorActionPreference = "Stop"

function Write-Success { param([string]$Message) Write-Host "‚úÖ $Message" -ForegroundColor Green }
function Write-Info { param([string]$Message) Write-Host ">> $Message" -ForegroundColor Cyan }

function Test-CommandExists {
  param([string]$Command)
  try { Get-Command $Command -ErrorAction Stop; return $true } catch { return $false }
}

function Test-And-Install-Rust {
  Write-Info "Checking Rust runtime..."
  if (Test-CommandExists "rustc" -and Test-CommandExists "cargo") {
    $version = (rustc --version).Split(' ')[1]
    Write-Success "Rust ready ($version)"
  } else {
    Write-Host "‚ö†Ô∏è Rust missing. Downloading..." -ForegroundColor Yellow
    $url = "https://win.rustup.rs/x86_64"
    $path = "$env:TEMP\rustup-init.exe"
    Invoke-WebRequest -Uri $url -OutFile $path
    Start-Process -FilePath $path -Wait -NoNewWindow
    $env:Path = [System.Environment]::GetEnvironmentVariable("Path", "Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path", "User")
  }
}

try {
  Test-And-Install-Rust
  cargo build --release
} catch {
  Write-Host "üöß Fatal error during setup: $_" -ForegroundColor Red
  exit 1
}
```

---

## Chapter 3: Pitfalls

1. **Environment ghosting**: After installing a tool, reload the shell (`source ~/.cargo/env` or refresh `$env:Path`) so the current session sees the updated PATH.  
2. **Execution policy traps**: Advise Windows users to run `Set-ExecutionPolicy RemoteSigned -Scope CurrentUser` before running unsigned `.ps1` scripts.  
3. **Unattended mode**: If the script runs in CI (GitHub Actions, etc.), interactive prompts hang the pipeline. Provide flags like `--unattended` or `-y` to bypass confirmations.
