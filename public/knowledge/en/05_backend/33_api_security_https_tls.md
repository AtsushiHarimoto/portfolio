# 33. 中間人與混血加密：HTTPS 與 TLS 握手防禦戰 (API Security)

> **類型**: 網路底層資安科普
> **重點**: 突破應用層 JWT 的盲點。深入 OSI 傳輸層，拆解全網際網路防範咖啡廳 Wi-Fi 竊聽 (MITM) 的終極護盾：**HTTPS**，以及其底層融合「非對稱」與「對稱」加密的奇蹟設計：**TLS 交握 (Handshake)**。

---

## 前言：就算拿到房間鑰匙 (JWT)，你還是在裸奔

許多開發者誤以為只要 API 掛上了 `Bearer Token (JWT)`，系統就固若金湯。
大錯特錯。HTTP 明文傳輸的本質，就像你在人聲鼎沸的星巴克裡，把寫著密碼與 JWT 的明信片，一路從台灣交給幾十個路由器 (Router) 傳遞到美國的 AWS。
任何一個惡意路由器只要按下「側錄」，你的系統權限就會瞬間被盜走。這被稱為**中間人攻擊 (Man-In-The-Middle, MITM)**。

為了讓這張明信片變成無法暴力破解的「保險箱」，**HTTPS (HTTP + TLS)** 應運而生。它不是一種新協議，它是在 HTTP 與底層 TCP 之間，硬生生砸入一層名為 **TLS (前身為 SSL)** 的「黑曜石裝甲牆」。

---

## 1. 密碼學的殘酷抉擇：非對稱 vs 對稱加密

要打造這個保險箱，人類面臨了密碼學的兩難：

| 陣營                                               | 運作原理                                                                                                                                                                                 | 致命缺點                                                                                                                              |
| :------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
| **對稱加密**<br>(Symmetric)<br>如 `AES`            | **「同一把鑰匙」**。雙方用同一把鑰匙（如密碼 `1234`）來上鎖與解鎖。運算極度神速，適合加密幾百 GB 的大檔案。                                                                              | **「送鑰匙的死穴」**。第一次通訊時，你要怎麼把這把唯一鑰匙交給伺服器，而不被中間人偷看到？鑰匙一被偷，後續加密全毀。                  |
| **非對稱加密**<br>(Asymmetric)<br>如 `RSA` / `ECC` | **「一對鑰匙」**。伺服器永遠私藏【私鑰 (解鎖用)】，並把【公鑰 (只能上鎖)】大方送給全宇宙。<br>瀏覽器拿「公鑰」鎖住機密寄回給伺服器。就算中間人攔截，因為他沒有「私鑰」，一輩子都打不開。 | **「運算龜速」**。其背後是龐大的質數數學難題。如果每一次看 Netflix 都要用 RSA 加密每一幀畫面，伺服器與手機的 CPU 會在幾秒內直接燒毀。 |

**難道沒有兩全其美的方法嗎？**
有，那便是人類智慧的結晶：**「混血加密 (TLS Handshake)」**。

---

## 2. 三次握手到 TLS 交握的史詩之旅

當你在瀏覽器輸入 `https://bank.com` 時，會發生一場不到一秒鐘但在底層極度瘋狂的外交交涉：

1. **底層 TCP 三次握手 (3-way Handshake)**：雙方先確認網路實體線路是通的。
2. **TLS 握手階段一 (Client Hello & Server Hello)**：
   - 瀏覽器：_「嗨，支援 TLS 1.3 嗎？我帶來了一串隨機亂數 A。」_
   - 伺服器：_「支援！這是我用『非對稱加密 RSA』算出來的一張身分證 (**SSL 憑證**與**公鑰**)，我也附上我的隨機亂數 B。」_
3. **終極驗證 (Authentication)**：
   - 瀏覽器立刻翻閱內建於作業系統內的「全球可信賴憑證機構名單 (CA, 如 Let's Encrypt)」。比對這個憑證是否造假。一旦發現憑證是別人偽造的，畫面會立刻噴出紅色的 `安全連線失敗`。
4. **極致的魔法 (建立 Session Key)**：
   - 瀏覽器利用剛剛的亂數 A、亂數 B，偷偷用超級數學算出了一把 **「全新的對稱加密密碼 (Session Key)」**。
   - 瀏覽器用伺服器給的 **「大方公鑰」將這把 Session Key 死死鎖住，然後丟回給伺服器**。
   - 伺服器收到後，拿出只有自己有的 **「絕對私鑰」** 將其解開。
   - **至此，全宇宙只有「瀏覽器」與「伺服器」知道這把輕快的 Session Key 是什麼！** (中間人就算偷錄了也是一團亂碼)。
5. **後續傳輸 (Symmetric Encryption)**：
   - 完成交握！從這一秒起，後續的千萬句聊天、千萬個影片封包，雙方全部改用便宜又極速的對稱加密 (如 AES) 搭配 Session Key 進行高速飆車。

這就是 TLS 的核心精神：**「用昂貴的非對稱加密，在眾目睽睽下偷運一把對稱加密的鑰匙，然後用這把鑰匙高速聊天。」**

---

## 💡 Vibecoding 工地監工發包訣竅

在使用 AI Agent 進行本地測試或架署生產環境時，請強制要求掛上這層防彈盾牌：

> 🗣️ `「你在撰寫這個處理付費回調事件 (Webhook) 的 Node.js 微服務時，絕對不允許以 HTTP 明文暴露出網段外！請務必教我如何透過 Nginx Reverse Proxy 或 Cloudflare Tunnel 為其披上 HTTPS / TLS 憑證外衣，否則我們的 Stripe 簽章與金流機密將直接死於任何路由節點的側錄分析器之下！」`
>
> _(附註：這也是針對內部系統【零信任安全架構】中 Server-to-Server 之間強制推行 mTLS 的唯一底層原理！)_
