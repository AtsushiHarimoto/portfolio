# 25. Distributed Hearts: Consistent Hashing and Snowflake Algorithm (Distributed Algorithms)

> **Type**: Distributed System Algorithm & Underlying Architecture Primer
> **Focus**: When a single server scales to a server cluster, we face two devastating pain points: "Cache Avalanche when adding/removing machines" and "ID conflicts generated by multiple databases." This article reveals two savior algorithms: **Consistent Hashing** and **Twitter Snowflake ID**.

---

## Prelude: When Single-Machine Logic Collapses in the Cloud

In the single-machine era, if you want to store cache, you store it in a memory `Map`; if you want a unique ID, you ask the relational database for `Auto Increment`.
However, arriving at the "Handling a Million Traffic from Scratch" chapter in the ByteByteGo textbook, where the server becomes a matrix of a hundred machines, these two lazy methods will instantly paralyze the entire system. We need "Distributed Algorithms" that rely on the pure beauty of mathematics without central authority.

---

## 1. Saving Cache Avalanche: Consistent Hashing

### ğŸ’£ The Disaster of Traditional Clusters: `Hash(key) % N`

Suppose you have 4 Redis cache servers (N=4). Moyin passes an image ID `1234`, and we use hashing to calculate which server this image should be placed on:
`1234 % 4 = 2` â¡ï¸ Oh, this image is placed on server `#2`. This method is fast and fair.

**Here comes the tragedy**: If server `#2` burns down tomorrow, N instantly becomes 3.
The system recalculates `1234 % 3 = 1` â¡ï¸ The image suddenly goes to `#1` to be found.
Not just this image, but the remainder paths of "all the caches in the entire universe" are completely messed up! This is called a "Cache Avalanche / Penetration". Countless sweating empty-handed connections will directly rush to the underlying database and smash it to pieces.

### ğŸ© Consistent Hashing: The Perfect Ring Universe

To solve this pitfall, engineers pinched out a "Hash Ring" composed of $2^{32} - 1$ slots.

- **Inserting Nodes**: The IPs of the 4 servers are also hashed and placed at specific marks on the ring.
- **Inserting Data**: After hashing the image ID, it is also placed on the ring. Then **"go clockwise, the first server encountered will be entrusted with the storage!"**
- **Immortal Golden Body**: When you unplug server `#2`, only those data originally entrusted to `#2` (about 1/4 of the total), going clockwise, will now encounter server `#3`. Since "the total length of the ring has not changed (% N disappeared)", the remaining 3/4 of the cache still hits 100%. The impact of cluster scaling drops from 100% to 25%!
- **Virtual Nodes to Prevent Imbalance**: If the servers are cut unevenly leading to massive traffic jams in a certain section, we will create hundreds of "Virtual Nodes" for each physical machine, evenly sprinkled on the ring, achieving extreme load balancing.

---

## 2. Abandoning Dependency: Global Unique ID Generator (Twitter Snowflake)

When the database is sharded into 10 independent small databases, you can no longer rely on the Auto Increment of a certain database. Because database 1 and database 2 will both generate `"ID: 1"` at the same time, which is a devastating primary key conflict.

Can we use standard UUID (36-character string)?
No! UUID is too fat and has no sequence. If used as a MySQL primary key (B+ Tree), every write will trigger an extremely violent "Page Split," crashing database write performance.

### â„ï¸ Snowflake Algorithm: Pure Numeric IDs that Act Independently and Never Repeat

The **Snowflake** algorithm invented by Twitter allows every machine in the cluster "not to communicate with each other" but still individually shoot out tens of thousands of pure numbers (64-bit Long type) within 1 millisecond, guaranteeing:

1. **Absolutely never repeat**
2. **Possess chronological orderability (Time-Sortable)**

**This mysterious 64-bit structure is brutally dissected as follows:**

- **[41 bits] Timestamp**: Records the current milliseconds (enough to use for 69 years! It guarantees that numbers generated later are absolutely larger).
- **[10 bits] Datacenter/Machine ID**: Each generator is assigned an exclusive code when leaving the factory (supports a cluster of up to 1024 machines).
- **[12 bits] Sequence Number**: If a machine generates multiple records within the same millisecond, these 12 bits add 1 for every generation (enough to generate 4096 different IDs in one millisecond).
- **[1 bit] Reserved Sign Bit**: Fixed at 0.

Relying on "time difference + machine identity difference + microsecond-level sequence number", a sky full of dancing and unique snowflakes can be dropped in the distributed world.

---

## ğŸ’¡ Vibecoding Instructions

If you command the AI architect to build a giant service with a distributed nature, these two terms will shock the AI:

> ğŸ—£ï¸ `"This comment system will cross borders and a Sharding database cluster in the future. You are forbidden to conveniently rely on the native Auto-Increment of relational data tables. Please implement for me (or import the corresponding npm module) a global ID generator based on the Twitter Snowflake algorithm to ensure Time-Sortable index performance under high concurrency!"`
>
> ğŸ—£ï¸ `"Regarding the routing dispatch strategy of this Redis cluster automatically scaling in Cloud K8s, the stupid Modulo Hash is forbidden. Please introduce [Consistent Hashing] plus a Virtual Nodes patch, so that during peak times when Kubernetes automatically destroys Pods, it won't pull down the entire cache buffer pool into an avalanche!"`
