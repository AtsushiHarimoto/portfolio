# 42. 推翻 CRUD 霸權：CQRS 與事件溯源 (Event Sourcing)

> **類型**: 微服務頂級設計模式
> **重點**: 當你發現資料庫「讀取」與「寫入」的衝突把系統效能拖垮時，這套架構將徹底顛覆你對資料庫的認知。本章帶領大家拋棄古老的 CRUD，進入連金融級銀行或大型 ERP 系統都在使用的終極架構：**CQRS 與事件溯源**。

---

## 前言：為何 CRUD 會走向死亡？

我們從學寫程式的第一天，就被教導 **CRUD (Create, Read, Update, Delete)**。
你要更新「Moyin 的錢包餘額」，就是下達這句：
`UPDATE wallets SET balance = balance - 100 WHERE user_id = 1;`

在流量小的時候，這很美好。但在高併發微服務叢集中，**致命痛點**如下：

1. **讀寫互卡 (Lock Contention)**：當老闆正在撈取「本月千萬營收的 超級 JOIN 複雜報表 (讀取)」時，會把資料庫鎖死。這導致外面的使用者買東西時「寫入付款」被迫排隊，畫面瘋狂轉圈圈。
2. **失去歷史真相 (Loss of Intent)**：當餘額變成了 `$500`，你根本不知道發生了什麼事！是被扣手續費？是系統 Bug？還是他買了東西？**因為 `UPDATE` 操作「覆蓋 (Overwrite)」並且抹殺了歷史的案發現場。**

---

## 1. 勞燕分飛：CQRS (命令與查詢責任隔離)

為了解決「讀」跟「寫」的效能衝突，大廠架構師提出了 **CQRS (Command Query Responsibility Segregation)**。
這套思想極其極端：**「讀取」與「寫入」必須強制分家，甚至連資料庫都要分開！**

### ✍️ 命令端 (Command) —— 負責「寫入」

- 專門處理會改變狀態的操作 (如付款、發文)。
- 後端使用如 MySQL 這類極其注重交易 ACID 安全性的**關聯式資料庫**。
- 它不在乎「讀取」的效能不能，只要確保寫入防撞與絕對正確即可。

### 👁️ 查詢端 (Query) —— 負責「讀取」

- 專門處理畫面上的展示 (如查看餘額、列出所有文章)。
- 後端換成 Elasticsearch 或是 Redis 等 **NoSQL 資料庫**。這些資料庫的結構會被刻意設計成「為前端畫面量身打造」的 View，前端連 JOIN 都不用，直接拿了就印出來，速度神快！

**問題來了：這兩邊的資料庫怎麼保持同步？**
答案是透過 **Kafka 或 RabbitMQ**，利用**非同步事件 (Event Driven)** 將 Command 邊寫入的結果，拋傳到 Query 邊的資料庫。

---

## 2. 只有帳本，沒有餘額欄位：事件溯源 (Event Sourcing)

要將 CQRS 發揮到極致，架構師會直接連 MySQL 裡的 `balance` 欄位都刪掉！

### 📜 所有的改變，都是一場「事件」

在 Event Sourcing 架構中，系統**永遠不存「當下的狀態」，系統只存「發生的事件流」**。
資料庫 (如 EventStore DB 或 Kafka) 從頭到尾只有這一個長長的陣列 (極速的 Append-only 寫入，沒有 Lock 問題)：

1. 【事件】`UserCreated` (Moyin 加入了)
2. 【事件】`MoneyDeposited` (匯入 $1000)
3. 【事件】`ItemPurchased` (買劍扣了 $200)
4. 【事件】`ItemPurchased` (買盾扣了 $300)

### 🧮 重播案發現場 (Replay)

- **如果要查餘額怎麼辦？**
  把他人生至今所有的事件從頭「重播 (Replay) 加減一遍」，就能得出餘額是 $500。
- **如果要查 Bug？**
  太完美了！因為你從沒用 `UPDATE` 覆蓋過任何數據，任何的駭客竄改或系統錯誤，都在事件流中被死死釘在恥辱柱上。
- **如果要新增「年度消費圓餅圖」功能？**
  傳統架構得從今天開始慢慢收集紀錄。在事件溯源中，只要把舊的事件陣列「從盤古開天再播一遍，灌入新的 MongoDB 圓餅圖集合」，昨天上線的新功能，今天就擁有過去 10 年的圖表資料！

---

## 💡 Vibecoding 工地監工發包訣竅

在使喚 AI 為您重構一套牽涉金融交易或是嚴格稽核制度的核心引擎時：

> 🗣️ `「你在幫我設計這套【帳戶資金總帳微服務】時，請立刻停止給我寫 UPDATE 的 Entity 模型！這是對財務系統的褻瀆。我要求你套用【CQRS 與 Event Sourcing (事件溯源)】設計模式。寫入端 (Command) 必須將提款動作轉化為 Immutable (不可變) 的 Event 流，並 Append 寫入 Kafka。然後由獨立的 Worker 收聽這些事件，來即時更新 (Project) 我們 MySQL 裡負責給前端畫面快速查詢 (Query) 用的視圖表 (Read Model)！」`
