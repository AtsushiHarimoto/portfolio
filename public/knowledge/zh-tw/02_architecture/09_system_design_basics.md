# 09. 系統設計漫遊指北 (System Design Basics)

> **類型**: 系統架構基礎科普  
> **重點**: 白話直譯後端開發常提及之「微服務」、「API 閘道器」與「非同步隊列」等核心工程術語，幫助初學者建立系統宏觀藍圖。

---

## 1. 系統拓撲：單體架構 vs 微服務架構

分散式系統中，最核心的兩大派系對決即是系統元件的組織方式：

| 架構模式                       | 概念比喻與技術特徵                                                                                      | 痛點與優勢分析                                                                                                                 | Moyin 專案之決策                                                                      |
| :----------------------------- | :------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------ |
| **單體架構 (Monolithic)**      | **「極度緊密的小套房」**。<br>所有的程式邏輯、功能模組皆編寫並封裝於同一個執行緒與專案資料夾內。        | 💥 **痛點**：只要單一功能（如登入驗證）發生記憶體溢出，整台伺服器（包含核心的 AI 服務）將骨牌式崩潰。                          | ❌ 已屏棄。此架構無法適應具備高負載差異的 AI 產品。                                   |
| **微服務架構 (Microservices)** | **「專業分工的工業園區」**。<br>將功能依業務邏輯拆分為獨立運作的微型專案，彼此間透過網路 API 傳遞資料。 | ✨ **優勢**：登入服務停機，不影響繪圖服務運作。更可針對特定耗能服務（如 ComfyUI）單獨分配高階 GPU 運算資源，展現極大擴充彈性。 | ✅ **全面採用**。專案目錄下 `moyin-gateway`, `moyin-comfyUI` 等皆為獨立運行之微服務。 |

> 💡 **最佳實踐 (Best Practice)**：
> 微服務並非銀彈。其本質為「將一個巨型應用程式，解耦為多個獨立維護的微型程式，並強制它們透過定義良好的 RESTful 或 gRPC 介面進行通訊」。

---

## 2. API Gateway (應用程式閘道器)

- **傳統痛點**：在微服務架構下，若沒有閘道器，前端 (Client) 必須硬編碼存取數十個不同微服務的 IP 與埠號 (Port)。一旦後端拓撲更動，前端即需強制停機更新。
- **Gateway 之存在意義**：扮演微服務叢集的「單一入口保全」或「總機」。
- **實際運作**：所有來自前端的請求（如獲取玩家資料或生成圖片）皆統一發送至 Gateway。Gateway 負責攔截、驗證身分 (Auth)，並根據 API 路徑**反向代理 (Reverse Proxy)** 將請求路由至正確的後端微服務。

> 🏢 **於 Moyin 專案之體現**：
> 當前端發起與大語言模型對談之請求時，並不會直接呼叫 OpenAI 的端點；而是統一敲擊 `moyin-gateway` 服務。由 Gateway 內的負載均衡器與成本路由策略，動態決定此刻應調用雲端 Claude 抑或是本地端 Ollama 模型。前端對此底層切換完全無感。

---

## 3. 非同步任務隊列 (Async Message Queue)

- **同步阻塞之夢魘 (Synchronous Blocking)**：若請求需消耗大量時間（如生成一張高畫質 AI 圖片需 3 分鐘），在同步架構下，前端的 HTTP 請求將被掛起 (Hang)，導致介面死鎖並極易發生逾時中斷 (Timeout)。
- **佇列架構之解法 (Asynchronous Queue)**：
  如同「餐廳抽號碼牌系統」。
  1. 使用者發起耗時請求，系統立即返回一組**任務追蹤碼 (Task ID)**。
  2. 該任務參數被推送至**訊息佇列 (Message Queue，如 RabbitMQ 或 Redis)** 存放。
  3. 背景部署的幕後工作節點 (Worker) 依序從佇列中提取任務並默默運算。
  4. 運算告竣後，透過 WebSocket 主動推播或讓前端利用 Task ID 定時輪詢 (Polling) 取回結果。

> 🌟 **容錯神兵：Temporal**
> 一般任務佇列若遇伺服器重啟將會流失未完任務。本專案將逐步導入之 **Temporal** 引擎，專注於管理「長時事務 (Long-running Workflow)」。它能以狀態機的形式確保持久化，即便斷電重啟，任務依然能從中斷點恢復執行，實現企業級的可靠性。

---

## 4. 負載均衡 (Load Balancing)

- **情境**：因應產品爆紅，單一伺服器之 CPU 與網路吞吐量面臨頂峰極限。
- **解決方案**：平行擴寫（Scale-out），部署多台運行相同微服務之伺服器節點，並於前端介接 **負載均衡器 (Load Balancer, 如 Nginx 或 HAProxy)**。
- **運作機制**：負載均衡器依循特定演算法 (如輪詢 Round-Robin 或最少連線數 Least Connections)，將湧入的高併發流量均勻分派至後端各個工作節點，避免單一節點過載宕機，實現系統的高可用性 (High Availability)。

---

## ✅ 架構術語驗收清單

系統設計之核心哲學在於「權衡 (Trade-offs)」。Moyin 專案盡可能將複雜狀態與防禦機制收斂於後端，以換取前端介面的極致輕量化。

檢視以下陳述，確認您是否已掌握本章核心架構思維：

- [ ] 🗣️ **「由於該 API 涉及深度學習推論，可能耗時逾 30 秒，請協助重構為『非同步 (Async) 背景佇列任務』，並遵循先返還 Task ID 的設計模式。」**
- [ ] 🤖 `我清楚微服務架構旨在隔離崩潰風險與提升擴展彈性，雖然這將墊高運運維與除錯之複雜度。`
- [ ] 🤖 `我明瞭 Load Balancer 的職責是於高流量場景下，均勻分配請求至多台橫向擴展之伺服器，達成高可用性。`
- [ ] 🤖 `我理解 Message Queue (或進階之 Temporal 服務) 能以非同步方式承載耗時任務，保證任務狀態的持久性與最終一致性。`
