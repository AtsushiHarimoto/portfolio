# 03.4. Git マージ・トポロジ最良事例

> **種類**: バージョン管理ワークフロー  
> **重点**: デフォルトの fast-forward マージが履歴を破壊する理由と、`git merge --no-ff` で機能区切りを残す重要性を解説します。

---

## 要約

fast-forward マージは機能ブランチを本線に平坦に並べてしまい、「いつそのブランチが作られたか」「どのコミットがそのリリースに属するか」が失われます。Moyin では `--no-ff` を義務化し、マージコミットを残してツリー構造を保ちながら、機能単位でのリバートを保証します。

---

## 1. マージのトポロジ比較

### ❌ Fast-forward（落とし穴）

- `git merge feature-branch` は dev がその間何もしていなければポインタを前進させるだけ。  
- グラフが一本線になるため機能の痕跡が消える。  
- 緊急ロールバック時、どのコミットが該当するのか不明瞭になります。

### ✅ --no-ff マージ

```bash
git merge --no-ff feature-branch -m "Merge feature/auth-system: JWT dual auth"
```

- 機能ブランチは常にマージコミットで閉じる。  
- そのマージノードがすべての子コミットをカプセル化。  
- `git revert <merge>` でその機能だけを精密に切り離せます。

---

## 2. 厳格な合併 SOP

1. **作業ツリーのクリーンチェック**  
   ```bash
   git status  # working tree clean であること
   ```
2. **差分・統計の確認**  
   ```bash
   git log dev..feature-branch --oneline
   git diff --stat dev feature-branch
   ```
3. **ベース同期**  
   ```bash
   git checkout dev
   git pull origin dev
   ```
4. **合併（No Fast-Forward）**  
   説明的なメッセージを添える。  
5. **プッシュ**  
   ```bash
   git push origin dev
   git log --oneline -n 3
   ```
6. **分支の掃除**  
   ```bash
   git branch -d feature-branch
   git push origin --delete feature-branch
   ```

---

## 3. 災害復旧

```bash
git log --oneline --merges
git revert -m 1 <merge-hash>
```

`-m 1` はメインラインを保持し、マージ先の変更だけを打ち消します。履歴を書き換えることなく、即座に事故を取り除ける。
