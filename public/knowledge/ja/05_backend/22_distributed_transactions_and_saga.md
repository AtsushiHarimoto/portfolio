# 22. 微服務一致性危機：分散式交易與 Saga 補償模式 (Distributed Transactions)

> **類型**: 分散式系統與後端架構科普
> **重點**: 探討當系統從宏大單體 (Monolith) 裂解為微服務 (Microservices) 時，過往資料庫「要嘛全成功，要嘛全失敗」的 ACID 神話如何破滅。深入解析 ByteByteGo 力推的非同步一致性解法：Saga Pattern 與 Transactional Outbox (發件匣模式)。

---

## 前言：當「資料庫」被切成了孤島

在傳統單體架構中，如果一名玩家結帳購買了虛擬寶物，我們只需要開啟一個資料庫連線 (例如 MySQL)，下達指令：
`BEGIN; 扣除玩家金幣(); 新增道具至背包(); COMMIT;`。
只要中間有任何一行崩潰爆出錯誤，資料庫會霸氣地觸發 `ROLLBACK`，一切就像沒發生過一樣，錢沒扣，寶物也沒給。這是我們對關係型資料庫無比信任的基石 (ACID)。

然而，當系統巨大化，演變成**微服務架構**後，這套邏輯徹底失靈：
「金幣系統」由一個團隊掌控，後方是 PostgreSQL。
「背包系統」由另一個團隊掌控，後方是 MongoDB。
**這兩座資料庫老死不相往來，根本無法協同進行 `ROLLBACK`。這就引爆了微服務最凶險的痛點：「分散式交易 (Distributed Transactions)」**。萬一金幣系統扣款成功，呼叫背包系統發貨時卻遭遇網路斷線，玩家就會陷入「錢沒了，東西也沒拿到」的極度憤怒中。

---

## 1. 悲觀獨裁者的末路：2PC (兩階段提交)

早年，為解決分散式交易，工程師發明了 `Two-Phase Commit (2PC)`。
這需要一位「全域協調者 (Coordinator)」跳出來，同時鎖住金幣資料庫與背包資料庫：

- **階段一 (Prepare)**：協調者問雙方「你們準備好扣錢跟發貨了嗎？都不准動！」(此時雙方資料庫都被嚴格套上 Lock)。
- **階段二 (Commit)**：雙方都回覆 OK 後，協調者才下達最終指令「好，一起寫入！」。

❌ **致命死穴**：這是一種重度阻塞的「同步枷鎖」。在準備階段，資料庫資源會被死死鎖住以防他人竄改。這意味著一旦採用 2PC，整個高併發系統的吞吐量 (Throughput) 將會呈斷崖式雪崩，完全無法應付網際網路級別的海量連線。

---

## 2. 微服務的新生存法則：Saga Pattern (長事務補償模式)

為打破 2PC 的鎖死僵局，擁抱高吞吐量的現代架構 (如 ByteByteGo 推薦) 捨棄了「絕對同時發生」的幻想，改為追求 **「最終一致性 (Eventual Consistency)」**。

Saga 的精神是：**不需要全域上鎖。將一個跨部門大交易，徹底劈碎成多個本地小交易。如果前面的小交易成功，後面的卻不幸失敗，我們不搞回滾 (Rollback)，而是觸發「補償性動作 (Compensating Actions)」來修補歷史的錯誤。**

### 🧩 情境演練：Moyin 的生成點數商城

假設用戶要花 50 點訂閱專屬 AI 角色，包含三個本地交易任務：
`[服務 A：扣除點數] ➡️ [服務 B：解鎖角色權限] ➡️ [服務 C：發送歡迎 Email]`

**成功劇本**：A 成功 ➡️ 通知 B。B 成功 ➡️ 通知 C。C 成功，整條鏈路 (Saga) 圓滿落幕。

**失敗補償劇本 (Saga 退款機制)**：

1. **[服務 A]** 成功扣除點數。
2. **[服務 B]** 在試圖解鎖角色時，發現該角色已下架，引發錯誤 (Failed)。
3. 此時，Saga 協調器 (或是服務 B 自己) 發出警報，緊急啟動 **反向補償鏈路的「退款部隊」**：
   - 即刻向 **[服務 A]** 下達「補償指令 (Compensating Transaction)`：`將該玩家的 50 點退還回去，並附上失敗原因。`

Saga 大幅解開了資料庫鎖的束縛，讓各系統跑得飛快，代價是工程師必須為每一個「寫入動作」額外準備專屬的「撤銷/退款動作」。

---

## 3. 保障訊息絕對抵達：發件匣模式 (Transactional Outbox)

在 Saga 之中，微服務 A 扣完錢後，必須「發送訊息 (Event)」通知微服務 B。但如果扣錢剛成功，伺服器卻突然在發送訊息前斷電了怎麼辦？這就是著名的「雙寫一致性難題 (Dual-Write Problem)」。

為防訊息遺失，業界標配是 **發件匣模式 (Outbox Pattern)**：
微服務 A 不直接向外拋出訊息，而是在自己的資料庫中，新增一張名為 `Outbox (發件匣)` 的表單。

1. 在**同一個本地資料庫交易 (Local Transaction)** 內，執行：`扣除點數(); INSERT INTO Outbox (事件：通知 B 解鎖角色); COMMIT;` (這保證了兩者絕對同生共死)。
2. 啟動另一支獨立背景程式 (Message Relay) 死命盯著 `Outbox` 表。一旦發現新信件，不管重試幾百次，必定要將其扔進發報機 (如 Kafka 或 RabbitMQ)，成功送達後再將 `Outbox` 的紀錄劃死。
   如此，便達成了防彈等級的訊息傳遞保證。

---

## 💡 Vibecoding 工地監工發包訣竅

若您命令 AI 架構師切割龐大的電商或點數結帳邏輯，請務必以此咒語約束：

> 🗣️ `「這段訂單建立與庫存扣減牽涉跨域微服務，絕對禁止你嘗試利用傳統 DB Transaction 全域綁定或 2PC 死鎖。請套用 Saga Pattern！我們接受高吞吐量的最終一致性；若庫存扣減失敗，請你確保觸發對等之前置退款服務 (Compensating Action)，並全程搭配 Outbox 模式將通知訊息拋入佇列，不准遺漏任何一滴資料！」`
