# 34. Google 検索の神レベルデータ構造：トライ木 (Autocomplete & Trie)

> **種類**: システム設計の実践と高度なデータ構造
> **重点**: リレーショナルデータベースにおける吐き気のするような `LIKE '%text%'` のフルテーブルスキャンを完全に捨て去ります。ユーザーが 1 文字打ち込むごとに「ミリ秒単位で 10 個の関連する提案ワード (Autocomplete) を吐き出す」という、Google や Amazon のような世界トップクラスの検索エンジンの背後にあるボス級データ構造：**Trie (トライ木 / プレフィックスツリー)** を解析します。

---

## 序：リレーショナルデータベースが入力ボックスに打ち負かされる時

ユーザーが検索ボックスに `ba` と入力した時、あなたはドロップダウンメニューが即座に `banana`, `batman`, `baseball` をヒントとして吐き出すことを期待します。
もしあなたが従来のリレーショナルデータベースを使ってこのような SQL を発行した場合：`SELECT word FROM search_history WHERE word LIKE 'ba%' ORDER BY search_count DESC LIMIT 10`。
おめでとうございます！数万件のデータしかない小さなショッピングモールであればまだ大丈夫かもしれませんが、10 億組のキーワードを持つ世界的規模の検索データベースであった場合、この曖昧検索 (Prefix Match) は B+Tree インデックス上で**フルテーブルスキャンを実行し、さらに並べ替え (ソート)** を行わなければならず、結果を返すまでに数十秒かかる可能性があります。
ユーザーが単語を打ち終わっても、あなたのドロップダウンメニューはまだ読み込み中のまま固まっているかもしれません。

「接頭辞 (Prefix)」に対する 1 億レベルの超高速検索を解決するために、科学者たちは専用の必殺技を発明しました。

---

## 1. パズルの解体：Trie (プレフィックスツリー)

Trie (トライ、Try と同じ発音) は、単一のアルファベットから構成される魔法の生命の木々の集まりです。

### 🌳 木の構造と構築

これは、従来のデータベースのように `batman` という文字列全体を 1 行として保存するわけではありません。文字を「徹底的に引き裂く」のです。

- ルートノード (Root) は空です。
- 第 1 層には `a, b, c...` を含む何十もの子ノードが生えています。
- `bat` を保存したい場合？ Root から `b` へ進み、`b` から `a` を生やし、さらに `a` から `t` を生やします。最後に `t` のノードに「終端記号 (End of Word)」をぶら下げて、コンピュータに「これで完全な 1 つの単語だ」と伝えます。
- 次に `bad` を保存したい場合？ システムは Root から見てすでに `b ➡️ a` という道が存在していることを発見するため、`a` から新たに `d` という道を分岐させるだけで済みます。

### ⚡ ミリ秒レベルの検索：ツルに沿って進む

あなたが `ba` と入力した時、コンピュータはもはや数十億のデータの中を盲目的に探し回ることはありません。直接 Trie オブジェクト上の `Root ➡️ b ➡️ a` というポイントに「空挺降下」します。
到着後、コンピュータは `a` の下にあるツルに沿って下へと手探りで進み、瞬時に既に存在する 2 つの道すじ：`bat` と `bad` を掴み取ることができます！
**検索の時間計算量は、極めて理不尽なことに「あなたが何文字打ち込んだか (接頭辞の長さ K)」のみに依存します。$O(K)$ という速度は、もはやチート級の直撃弾に等しいです！**

---

## 2. システム設計の地獄の試練：1 万人が争奪する Top 10 リスト

Trie の単語検索は極めて高速ですが、ユーザーは「**最も人気のある Top 10**」だけを見たいと思っています。もし私たちが `a` ノードにたどり着いた後、その下に 10 万個のマイナーな単語とメジャーな単語が存在していることを発見した場合、それらをすべて取り出して壮大なソートを行わなければならないのでしょうか？ それではまたもや大惨事になってしまいます。

### 🏆 空間を時間と引き換える王道：ノードキャッシュ (Node Cache)

$< 50\text{ ms}$ という厳格な応答要件を達成するためには、誰かが入力した時に初めて `Order By` を実行しているようではいけません。
この木には黒魔術がかけられています：**すべての中間ノードは、アルファベットを記録するだけでなく、その接頭辞を含む最も人気のある単語 Top 5 の配列を強引に「キャッシュとしてハードコーディング」しているのです**。

- `b` ノードの内部には次のように記録されています：`[{word: 'banana', hit: 100}, {word: 'batman', hit: 80}, ...]`。
- `b ➡️ a` ノードの内部にも、この Top リストが記録されています。

ユーザーが `ba` と打って `a` ノードに到達した時、システムはそれ以上下へは全く探しません。**直接このノードのお腹の中にある、あらかじめ計算済みの Top 5 リストをそのままユーザーに投げ返すのです！**
その代償としてこの木が占有するメモリは非常に肥大化しますが、システムのパフォーマンスは物理的な限界を突破します。

### 🏭 オフライン非同期再計算 (Data Sampling)

すべての中間ノードが巨大な Top リストを記録しているため、もし通行人が新しい単語を検索するたびに、この木に対して「すべての経路の人気リストをリアルタイムで更新する」よう要求すれば、この木は狂気じみた更新と書き込みの競合 (ライトアンプリフィケーション) によって死んでしまいます。
**解決策**：Trie 自体は「静的」な読み取り専用です！
ユーザーのクリックログはすべて Kafka や Hadoop に投げ込まれ、毎週または毎日、オフラインでのビッグデータ変数のバッチ再計算 (Batch Processing) が行われます。そして深夜になるのを待ち、「全く新しいホットリストを持った Trie」を生成し、一気にオンラインの古い木とすげ替える (Blue/Green Deployment) のです。

---

## 💡 Vibecoding 指令

検索エンジンやキーワード補助システムに直面した際、この語彙のセットを使用することで、最高水準のエンジニアリングコードを絞り出すことができます：

> 🗣️ `「この e コマースサイトの検索バーのための【自動補完 (Autocomplete) API】を設計する際、MySQL の LIKE % を使ってすべての商品名を検索することは禁止します！独立したマイクロサービスを立ち上げ、Redis またはローカルメモリを利用して【Trie (トライ木 / プレフィックスツリー)】を構築してください。そして木を構築する際、O(1) レベルの神速ドロップダウンメニュー体験を達成するために、その接頭辞を持つ Top 10 の人気単語プレフィックスを必ず枝ノード内にキャッシュ (Prefix Node Caching) するようにしてください！」`
