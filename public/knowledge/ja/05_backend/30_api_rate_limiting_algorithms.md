# 30. トラフィックの津波を防ぐ：API レートリミットアルゴリズム大解剖 (Rate Limiting)

> **種類**: システムアーキテクチャ防衛とアルゴリズム入門
> **重点**: 「1 分間に 10 回しか叩けない」といった素朴な防衛思考の抜け穴を打ち破ります。Stripe、AWS、そして業界トップクラスの Gateway (Kong など) が、悪意のあるクローラーや突発的な吹雪のようなトラフィックを防ぐために使用する究極の武器：**トークンバケット (Token Bucket)** と **スライディングウィンドウ (Sliding Window)** アルゴリズムを深く探求します。

---

## 序：なぜ単純な「カウンター」は一撃で崩れ去るのか？

初心者開発者がレートリミット (帯域制限) メカニズムを設計する際、通常は **「固定ウィンドウカウンター (Fixed Window Counter)」** アルゴリズムを実装します：

- **ロジック**: Redis 内に `user_123_minute_01` という Key を設定し、最大値を 10 にします。
- **動作**: リクエストのたびに +1 し、10 を超えたら拒否します。次の 1 分 (`minute_02`) になると、カウンターは 0 にリセットされます。

❌ **致命的な弱点：境界でのバースト貫通 (Burst at Edge)**
ハッカーはこのメカニズムの抜け穴を発見しました。彼は `00:00:59` の瞬間に 10 回のリクエストを送信し (ギリギリブロックされない)、続いて `00:01:00` の瞬間に再び 10 回のリクエストを送信します。
サーバーから見れば、「わずか 1 秒間」の間に 20 回の攻撃を受けたことになります！これはすでにあなたが当初想定していた上限の 10 回を超えています。あなたの防衛線は、このように「2 分間の隙間を突かれる」ことで突破されてしまうのです。

突発的なトラフィックと境界の抜け穴を徹底的に解決するため、アーキテクトたちは以下のような神レベルのアルゴリズムを開発しました：

---

## 1. 突発的な火力を許容する貯水池：トークンバケット (Token Bucket)

これは全世界で最も有名で、最も広く応用されているアルゴリズムです (Amazon や Stripe が提供するレートリミットの底辺にもこれが使用されています)。その強みは：**「普段は制限するが、たまの怒りの爆発は許容する」**という点にあります。

### 🪣 運用モデル

システムが各ユーザーに「バケツ (Bucket)」を一つずつ配給すると想像してください。

1. **容量制限 (Capacity)**：バケツには最大 100 枚の金貨 (Token) しか入りません。これを超えた分はバケツからこぼれ落ちて捨てられます。
2. **固定配給源 (Refill Rate)**：システムは「毎秒 10 枚」という安定した速度で、継続的にバケツに金貨を投げ入れます。
3. **消費対価**：ユーザーが API を 1 回呼び出すたびに、バケツから「金貨を 1 枚取り出す」必要があります。もしバケツが空で取り出せなければ、リクエストは直接 `429 Too Many Requests` を返します。

### 🏎️ 完璧な優位性：突発的なトラフィックをサポート (Burst-Friendly)

もしあるユーザーが普段は非常におとなしく、5 秒間何も操作しなかった場合、彼のバケツには 50 枚の金貨が蓄積されます。
突然、彼が API を同時に 50 回呼び出す重い操作ボタンを押したとします。バケツの中には「一度に 50 枚の金貨がある」ため、システムは瞬時にこれら 50 個の接続を通過させます！これは固定時間ウィンドウでは不可能な、非常にスムーズな体験です。
金貨を使い果たした後、彼は再び「毎秒 10 回しかつつくことができない」という厳格な制限に戻ります。

_(注：トークンバケットに似たものとして「リーキーバケット (Leaky Bucket / 漏れバケツ)」があります。これは強制的に一定量を滑らかに流出させることができ、e コマースのデータベースが押し潰されるのを防ぐためによく使用されます)。_

---

## 2. 境界点を封殺する精密顕微鏡：スライディングウィンドウ (Sliding Window)

もしあなたが金融取引システムを運営しており、たった 1 回の「突発的な爆発」も許すことができず、**死角のない極限まで滑らかな制限**を追求するのであれば、この仕組みを選んでください。

### 📜 Sliding Window Log (スライディングウィンドウ・ログ)

単純な数字を管理するのではなく、リクエストのたびにその「正確なタイムスタンプ (Timestamp)」を Redis の `Sorted Set` 内に記録します。
新しいリクエストが `00:01:30` に到着した時：

1. **クリーンアップ**：配列の中から、1 分前 (`00:00:30` より前) のすべての古いタイムスタンプを削除します。
2. **人数カウント**：もし残っているタイムスタンプの数が閾値よりも大きければ、残念ですが拒否します。少なければ通過させ、`00:01:30` を配列に追加します。
   ❌ **欠点**：高並行処理下では、通行人すべてのタイムスタンプを狂ったように記録し続けるため、メモリがその場で大爆発します (Memory-Intensive)。

### 🧠 Sliding Window Counter (スライディングウィンドウ・カウンター：究極の改良版)

固定ウィンドウの「メモリの節約」と、スライディングログの「死角のなさ」を組み合わせたものです。
次のリクエストが `00:01:30` に到着した時、システムは：

1. 「前の 1 分間 (00:00)」の総量を見つけ出します (仮に 5 回とします)。
2. 「現在の 1 分間のここまで (00:01)」の総量を見つけ出します (仮に 3 回とします)。
3. **加重比率**を利用して、過去 60 秒間の実際のトラフィックを推算します：
   `前の 1 分間の総量 * (100% - 現在すでに経過した秒数の割合 50%) + 現在の 1 分間の総量` = `5 * 0.5 + 3 = 5.5 回`。
   単純な中学生の数学を用いるだけで、境界のバースト波動を完璧に平滑化し、さらにメモリのオーバーヘッドはほぼゼロに近づきます！

---

## 💡 Vibecoding 指令

AI Agent を使用して外部に開放された Public API ノードを構築する際は、必ずレートリミット武器を設定することを強制してください：

> 🗣️ `「Express.js で外部 API の Rate Limiter ミドルウェアを設定する際、単純な Redis INCR を使用して【固定ウィンドウ (Fixed Window Counter)】を実装することは厳禁です。これにより境界でのバースト攻撃を受け、OOM(メモリ不足) によるクラッシュを引き起こすためです。【Token Bucket (トークンバケット)】アルゴリズムをサポートするレートリミットパッケージを導入し、Bucket Capacity を 50 に設定して、少量のフロントエンド並行リクエストの突発的な増加を許容するようにしてください！」`
