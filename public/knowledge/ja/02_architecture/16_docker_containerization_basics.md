# 16. Docker とサーバーコンテナ化技術 (Docker & Containerization)

> **種類**: システム環境とデプロイ基盤  
> **重点**: コンテナ化が「自分の環境では動く」という現象をどのように解消し、Docker のコアコンポーネントと Compose の編成ロジックを構築するかを解説します。

---

## 序：開発者と運用者の環境断層を埋める

チーム開発で最悪の断絶は「私のマシンでは動く」というセリフです。原因はエコシステムの非整合：A さんは macOS で Python 3.10、B さんは Windows で Python 3.12 かつ C++ ビルドツール無しでは、デプロイすると即座にシステムが壊れます。  
Docker はアプリとその実行環境を一体化してパッケージ化し、この悪夢に終止符を打ちます。

---

## 1. コンテナ vs 仮想マシン

一昔前は VMWare や VirtualBox による VM で隔離を得ていました：

- **VM**：ディスクを切って完全な Guest OS をインストール。隔離性は高いが重く、1 台起動に GB 単位の RAM と数分要する。
- **Docker コンテナ**：**「軽量な密閉ケース」**のような存在。ソースと依存だけを梱包し、ホストのカーネルを共有するため、イメージは数十MB、起動はミリ秒。普通のマシンでも数十〜百個のコンテナを並列で走らせられます。

---

## 2. Docker の三本柱

### ① Dockerfile（レシピ）

環境を宣言するテキスト：

```dockerfile
# Node.js 20 を含むベースイメージ
FROM node:20

# コンテナ内のワーキングディレクトリ
WORKDIR /app

# ソースコードをコピー
COPY . .

# 依存をインストール
RUN npm install

# 起動時のコマンド
CMD ["npm", "start"]
```

### ② イメージ（静的テンプレート）

Dockerfile から生成されるイメージは読み取り専用の鋳型。規定の環境が凝固しており、どこに持って行っても挙動は決定的です。

### ③ コンテナ（動的インスタンス）

イメージをリソースに結びつけて実行するとコンテナになります。イメージが図面、コンテナが建物に相当し、同一イメージから複数のコンテナを起動して水平スケールできます。

---

## 3. Docker Compose：多容器のオーケストレーション

Gateway、フロント、MongoDB、Redis など多くのマイクロサービスは起動順とネットワークの組み合わせが複雑です。手動ではミスを誘発します。

Docker Compose なら：

- `docker-compose.yml` で全サービス、依存、ブリッジネットワークを宣言。
- たった一つのコマンド：
  ```bash
  docker-compose up -d
  ```
- オーケストレーターが順番に起動し、ポートマッピングまで自動化。これが IaC（Infrastructure as Code）の入口です。

---

## 💡 Vibecoding 指令

AI に新サービスを構築させる際は次の指示を添えてください。

- [ ] 「`Dockerfile` と `docker-compose.yml` を用意し、ホストがアクセスできるマッピングポートを含めて、コンテナ内で一発で動作するようにしてください。」
- [ ] 「コンテナは VM に比べ、共有カーネルゆえに圧倒的にリソース効率が良い。」
- [ ] 「イメージは依存地獄から守る防御壁のような存在である。」
