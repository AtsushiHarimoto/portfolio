# 15. Git バージョン管理と CI/CD 自動化パイプラインガイド

> **種類**: 基礎エンジニアリング知識とベストプラクティス  
> **日付**: 2026-02-25

現代のソフトウェアエンジニアリングの協業において、AI Agent にコードの変更を単独で依存することは不十分です。システムの安定性を確保し、過去の変更を追跡するためには、**Git** と **CI/CD** が不可欠なコアインフラストラクチャとなります。本ガイドでは、これら 2 つの主要な技術メカニズムの運用モデルについて解説します。

---

## 1. Git：過去に遡る能力を備えたバージョン管理システム

バージョン管理がない環境では、ファイル名が `最終版.docx` や `絶対最終版.docx` など、追跡困難な混乱状態に陥りがちです。ソフトウェア開発において、このような管理方法は壊滅的な災難をもたらしますが、**Git** はまさにこの悩みを解決するために生まれたバージョン管理システムです。

### Git のコアメカニズム

1. **コミット (Commit)**：
   開発者や Agent がコードベースを変更し、「コミット」操作を実行するたびに、Git はその時点のコードの完全なスナップショット（Snapshot）を記録します。これにより、修復不可能な破壊的な変更が発生した場合でも、システムは任意の履歴状態に復元する能力を備えることができます。
2. **ブランチ (Branch)**：
   - **メインブランチ (`main`)**：通常、現在の本番運用（Production）または最も安定したコードバージョンを表します。
   - **機能ブランチ (Feature Branch)**：新機能の開発（例：`feature/new-ui`）やバグの修正が必要な場合は、独立したブランチで行う必要があります。これにより、隔離された開発環境が作成され、実験的な変更がメインラインの安定性に影響を与えないことが保証されます。
   - ブランチでの開発が完全にテストされ、エラーがないことが確認された後、マージ（Merge）操作を通じて変更が `main` ブランチに統合されます。

3. **マージコンフリクト (Merge Conflict)**：
   異なるブランチが偶然同じファイルの同じ行のコードに対して異なる変更を行った場合、マージ時に Git はどちらを保持すべきか自動的に判断できず、これがマージコンフリクトとなります。この場合、手動で介入して解決し、ロジックを確認して正しい変更部分を手動で保持する必要があります。

---

## 2. CI/CD：ソフトウェア自動検査とパッケージ展開パイプライン

コードが書き込まれ、バージョン管理センター（GitHub、GitLab など）にコミットおよびプッシュされた後、現代の開発プロセスでは、本番サーバーにファイルを手動でアップロードする方法を放棄し、代わりに **CI/CD (継続的インテグレーション / 継続的デプロイ)** システムに依存して、安定した完全に自動化されたソフトウェア配信パイプラインを構築します。

### CI (Continuous Integration - 継続的インテグレーション)

- **コア目標**：欠陥のあるコードがメインラインにマージされたり、本番環境に投入されたりする前に、ブロックして防ぐこと。
- **標準運用プロセス**：
  1. Agent が新しいコードをコミットしてクラウドリポジトリにプッシュ (Push) すると、CI サーバー（例：GitHub Actions ボット）が自動的にトリガーされます。
  2. システムは、クリーンで隔離された一時的な実行環境を自動的に設定します。
  3. システムは、事前に記述されたテストスクリプト群（単体テスト、統合テストなど）を自動的に実行します。エラーが発生したり基準を満たせなかったりした場合、そのコミットは失敗 ❌ とマークされ、`main` メインラインへのマージ権限が強制的にブロックされます。

### CD (Continuous Deployment - 継続的デプロイ)

- **コア目標**：スムーズかつ無痛で、高度に自動化されたバージョンリリースを実現すること。
- **標準運用プロセス**：
  1. CI 検査で全パス ✅ が確認され、ブランチが `main` へのマージを正式に承認された後、CD フェーズが正式に開始されます。
  2. システムは自動的にビルド (Build) プロセスを実行し、ソースコードを実行可能なアプリケーションパッケージにまとめます。
  3. システムは自動的に本番サーバーまたはクラウドコンテナ環境にログインを承認し、古いコードを置き換えて、影響のない再起動（Graceful Restart）を実行します。このプロセス全体には、人手による介入は一切必要ありません。

### ゼロ・ダウンタイム展開の戦術 (Zero Downtime Deployment)

数万人が同時に接続している正式な環境で、直接「古いファイルを上書きして再起動する」ことは、切断エラーを引き起こします。業界はこれに対処するため、極めて洗練されたリリース戦略を開発しました：

- **ブルーグリーンデプロイ (Blue-Green Deployment)**：
  - **方法**：同じホストシステムを同時に 2 セット 유지합니다（例：メインのブルー、バックアップのグリーン）。通常の運用時、ユーザーの Load Balancer は 100%「ブルー」を指しています。新バージョンがリリースされると、CI/CD はまず完全に隔離された「グリーン」環境に密かにデプロイし、テストエンジニアにチェックさせます。
  - **切り替えと撤退**：エラーが確認されない場合、Load Balancer のポインタは「パチン」と音を立て、ユーザーのトラフィックをブルーから「グリーン」に即座に 100% リダイレクトします。新バージョンが大規模なエラーを引き起こした場合、スイッチは 1 秒で「ブルー」の旧バージョンに戻り、**史上最速のロールバック (Rollback)** を実現します。欠点はハードウェアコストが高いことです（2 つの孤立したクラスターを維持する必要があります）。
- **カナリアリリース (Canary Release)**：
  - **方法**：初期の鉱夫が毒ガスをテストするためにカナリアを坑道に持ち込んだことに由来します。新バージョンをリリースする際、旧バージョンを完全に置き換えることは絶対にしません！代わりに、Gateway や Service Mesh を使用してトラフィックを傍受し、数百万人いるプレイヤーの中から**「トラフィックの 5% だけをランダムにサンプリングして、新バージョン (カナリア)の Pod にルーティングしてサービスを提供」**し、残りの 95% は引き続き安定した旧バージョンによって処理されます。
  - **観測とフルロールアウト**：この 5% のプレイヤートライアル期間中、Grafana ダッシュボードのアプリエラー率とサーバークラッシュ指標を注視します。これらのカナリアが問題なく動作していることが確認された後、徐々にバルブを 10%、50% と開き、最終的に 100% 新バージョンでカバーします。ブルーグリーン戦略と比較して、オンライン障害の影響範囲を最小の半径に正確に制御できます。

---

## 💡 Vibecoding 指令のコツ (Vibecoding Tips)

Moyin プロジェクトにおいて、私たちは GitHub Actions などのクラウド CI/CD サービスに大きく依存しています。したがって、たとえ AI Agent が「タスク完了」と報告したとしても、**クラウド CI システムの検査結果こそが、マージを最終承認するための客観的な基準となります。**サービスのクラッシュを引き起こすコードが送信された場合、パイプラインはそれを厳格にブロックします。

AI を活用してこのような自動化パイプラインを構築または調整する必要がある場合は、以下の正確なコマンド形式を使用することをお勧めします。

> `[CI/CD 構成リクエスト] GitHub Actions に適した YAML パイプラインスクリプトの作成を支援してください。仕様要件：main ブランチへの Push イベントが発生するたびに、まずは「npm run test (CI 検査)」を優先して実行する必要があります。その結果がすべて Pass したことを確認した後にのみ、後続の自動化デプロイ (CD) スクリプトのフェーズに進むことができます。`
