# Vibe Coding 自動化開発フロー (SOP)

## 概要

- 特定機能の開発や問題調査において、ユーザーはまず**プロジェクトスコープ (Project Scope)** と**ワークモード (RUN-DEV / RUN-QA)** を定義する必要があります。
- 標準ワークフロー (Workflow)：
  - **コマンド `RUN-DEV`**：標準開発 SOP
    - `新機能/バグ修正/リファクタリング -> ドキュメント修正/作成 -> コード実装 -> コードレビュー -> 欠陥修正 -> レビュー承認 (Review OK)`
  - **コマンド `RUN-QA`**：品質保証・テスト SOP
    - `UT/QA 仕様ドキュメント理解 -> テスト計画修正/作成 -> テストエンジニアリング実装 -> コードレビュー -> 欠陥修正 -> クリティカルパステスト -> テストレポート生成`

---

## プロジェクトスコープ (Project Scope) 境界制御

- タスク開始前に、以下のディレクトリ階層に従って厳密にインデックスする必要があります。タスクが複数のサブシステムにまたがる場合でも、**各ステップで現在のスコープ (SCOPE) を明示的にタグ付け**する必要があります（例：API / moyin-web / moyin-game / tests）。
- 厳格ルール：
  - すべての操作は指定されたプロジェクトパス内に限定されます。**境界を越えた変更は厳禁です**（ユーザーが明示的にクロスシステムリファクタリングを許可した場合を除く）。
  - ドキュメントの検索・閲覧時、システムは特定のノイズディレクトリを自動的に除外し、有効な要件ソースとして扱いません。

### 除外ディレクトリキーワードリスト

以下のディレクトリ（または同名キーワードを含むフォルダ）は、「要件ソース」としては一律強制除外されます：

- `pending`
- `review`
- `output`
- `LOG`
- `plan`
- `5.QA`
- `5.Q&A`
- `temp`
- `memo`
- `TODO`
- `reiview`（スペルミスの歴史的産物も除外対象）

> 例外：`review` ディレクトリは**最終出力成果物**の保存先です（本 SOP フローで書き込みを要求）が、「要件入力」ソースとして逆方向に使用することはできません。

---

## プロジェクトモジュールマトリクス（リポジトリ構造に基づく）

### モジュール 1：API サービス層 (Backend API Gateway)

- ソースコード：`projects/moyin-gateway/web2api`
- ドキュメントルート：`projects/moyin-gateway/docs`
- レビュー記録：`projects/moyin-gateway/docs/review`

### モジュール 2：Web アプリケーション (Moyin Web - Creator Studio)

- ソースコード：`projects/moyin-web`
- ドキュメントルート：`projects/moyin-web/docs`
- レビュー記録：`projects/moyin-web/docs/review`

### モジュール 3：ゲームフロントエンドエンジン (Moyin Game V1)

- ソースコード：`projects/moyin-game-v1/website`
- ドキュメントルート：`projects/moyin-game-v1/docs/`
- レビュー記録：`projects/moyin-game-v1/docs/review`

### モジュール 4：QA オートメーション (QA Automation)

- ソースコード：`projects/tests`
- ドキュメントルート：`projects/tests/docs/`
- レビュー記録：`projects/tests/docs/review`

### 成果物アーカイブ (Deliverables)

- 統一パス：`deliverables/`
- 標準出力構造：
  - `deliverables/01_要件定義`
  - `deliverables/02_基本設計`
  - `deliverables/04_開発`
  - `deliverables/05_単体テスト`
  - `deliverables/06_結合テスト`
  - `deliverables/07_総合テスト`
  - `deliverables/08_リリース`
  - `deliverables/09_運用保守`

> 注記：deliverables モジュールは外部レビュー・チーム間整合のための上位ドキュメントに特化しており、エンジニアリング仕様は `projects/*/docs` が唯一の技術的真実のソースです。

---

## ワークフロー共通制約（RUN-DEV と RUN-QA の両方に適用）

- **言語規範**：繁体字中国語を強制（英語の専門用語は許容）。特定のワークフローに独自の言語設定がある場合を除きます。
- **ロジック事前チェック**：実装前に、要件に以下が含まれていないか検証します：論理的矛盾 / 技術的実現不可能性 / 既存ドキュメントとの衝突。
  - 衝突が検出された場合：**衝突点とその影響を報告し、「仕様ドキュメントを修正する」か「コードベースを上書きする」かをユーザーに積極的に確認します**。明示的な同意なしに大規模リファクタリングを開始することは禁止です。
- **スコープロック**：すべての検索・出力操作は割り当てられたプロジェクトスコープ内に制限されます。

---

## コア開発 SOP（RUN-DEV フロー）

### ステップ 1：仕様ドキュメントレビュー（プロダクトマネージャー視点）

- **入力**：ユーザーが機能目標 / 欠陥説明 / 指定プロジェクトスコープを提供（スコープ未指定の場合、AI は ASK プロンプトをトリガーする必要があります）。
- **アクション（計画層 AI、例：Claude が実行）**：
  1. 対象システムの `docs/` ディレクトリから技術仕様と履歴制約をフィルタリングします。
  2. 「仕様ドキュメント vs 実行中コード」の間に乖離が見つかった場合、レビュー課題記録をまとめ、以下にアーカイブします：
     - `{プロジェクトドキュメントルート}/review/issues/`（命名規則：`DocReview-YYYYMMDD.md`）
  3. ユーザーの要件が断片的または内部矛盾を含む場合、FAQ としてまとめ、以下に出力します：
     - `{プロジェクトドキュメントルート}/review/FAQ/`（命名規則：`FAQ-YYYYMMDD.md`）

### ステップ 2：ドキュメント修訂（Doc-First 原則）

- **アクション**：計画層 AI が仕様ドキュメントのパッチと修正セクションを提案します。
  - 現在のプロジェクトの `docs/` スコープに限定されます。
  - 修訂内容は、下流のコード実装とユニット検証を支えるのに十分な精度を備えている必要があります。
- **分岐判断**：ユーザーがドキュメント修訂を否決した場合、フローはステップ 1 にリセットされ、要件境界を再整合します。

### ステップ 3：コード実装（実行層 - Antigravity/Codex）

- **アクション**：実行層 AI が最新の承認済みドキュメントに厳密に従ってコーディングします。
- **中断メカニズム**：実装中にロジックのギャップや未定義仕様に遭遇した場合：
  - 即座にコーディングを停止し、技術的課題を `{プロジェクトドキュメントルート}/review/FAQ/` に起票して計画層 AI に解決を委ねます。
  - 仕様が補完された後にのみコーディングを再開できます（AI が推測に基づいて実装することは厳禁です）。

### ステップ 4：コード品質レビュー（テクニカルアーキテクト視点）

- **アクション**：計画層 AI がスキャン・レビューを実施します：
  - 今回のタスクで生成されたコード差分（クォータ内）。
  - 影響を受けるコアロジックモジュール。
- **出力**：詳細なレビューレポートを `{プロジェクトドキュメントルート}/review/issues/` に格納（命名規則：`CodeReview-YYYYMMDD.md`）。
- **リスク分類**：
  - **P0 ブロッカー (Blocker)**：コア機能障害 / データ破損 / 重大セキュリティ脆弱性 / テスト阻害を引き起こします。
  - **P1 クリティカル (Critical)**：エッジケースバグ / メンテナンス性劣化 / ステートマシンロジック矛盾の高確率。
  - **リスク警告 (Warning)**：現時点で顕著な影響はないが、スケーリングや大規模モデル統合時に構造的リスクがあります。

### ステップ 5：パッケージングとコミット戦略（バージョン管理ゲート）

- **アクション**：確認を要求する前に、実行層 AI は完全なエビデンスチェックリストを提示する必要があります：
  - 変更ファイルマトリクス。
  - `git diff` サマリー。
  - `git log -n 10` トレースレビュー。
- **完了**：機能ポイントと論理ブロックごとに段階的にコミットします（各コミットが明確なエンジニアリング意味を持つことを保証）。曖昧な変更がある場合は、ASK をトリガーしてユーザーに再確認します。

---

## 品質保証・テスト SOP（RUN-QA フロー）

### ステップ 1：テストドキュメントマトリクスレビュー（QA エンジニア視点）

- **入力**：ユーザーが検証対象の機能境界 / 回帰テスト対象 / 指定プロジェクト（通常 `projects/tests` を対象プロジェクトにマウント）を提供します。
- **開始ポイント**：計画層 AI が対象プロジェクトの docs で「テスト可能性基準」と「受入基準」を検索します。
- **ブロッキング条件**：「テスト要件 vs コード現状」の間に構造的不一致が見つかった場合、テスト計画を**強制的に中断**し、衝突レポートを生成します：
  - `{対象プロジェクトドキュメントルート}/review/issues/` または `projects/tests/docs/review/issues/`。

### ステップ 2：テスト計画構築

- **アクション**：`projects/tests/docs/` にシステム的なテスト設計ブループリントを生成します。内容は以下を含みます：
  - テストカバレッジ境界（スコープ内）と除外（スコープ外）。
  - テストケースインベントリ（ユニット / E2E / 非機能）。
  - モックデータ、前提条件、期待結果（アサーション）。
  - 標準化されたクラッシュレポート構造。
- **アーカイブ先**：`projects/tests/docs/plan/`（命名規則：`TestPlan-YYYYMMDD.md`）。

### ステップ 3：テスト実装（実行層）

- **アクション**：実行層 AI がテスト計画に従って `projects/tests` ディレクトリにテストスクリプトを作成します。
- **不明なエッジケース**：曖昧な境界に遭遇した場合、`review/FAQ/` に記載して計画層の介入を求めます。

### ステップ 4：テストスクリプト品質レビュー

- **重点**：`projects/tests` 内のテストスクリプトをレビューします。テストカバレッジがコアリスク領域を対象としているか評価し、アサーションロジックの厳密性を検証します。
- **アーカイブ先**：`projects/tests/docs/review/issues/`（命名規則：`TestCodeReview-YYYYMMDD.md`）。

### ステップ 5：テスト完了とバージョンコミット

- **出力**：包括的なテスト結論レポートを `projects/tests/docs/report/` に自動生成（命名規則：`TestReport-YYYYMMDD.md`）。
- **バージョン管理**：RUN-DEV ステップ 5 と同じ規律 -- diff とログをレビューし、段階的にコミットします。

---

## コマンドセンター：日常インタラクションプロトコル

- 新しいタスクシーケンスを開始する際、ユーザーは 3 つの基本コマンドを提供する必要があります：
  1. **モード選択**：`RUN-DEV` または `RUN-QA`。
  2. **スコープ宣言**：API / moyin-web / moyin-game / tests（複数選択可、ただし最低 1 つ必須）。
  3. **目標定義**：コアタスクの一文説明 + 期待される受入状態（具体的であるほど AI の整合に有利）。
- 前提情報が不完全な場合、AI は `ASK` メカニズムをトリガーして不足情報を収集してから、ステップ 1 に進む必要があります。

---

## FAQ & トラブルシューティング (Troubleshooting)

### Q: なぜ AI エージェント（例：Claude）が頻繁に許可なくコードを変更するのですか？設定ミスですか、AI の理解力不足ですか？

**A: この過度に積極的な (Over-proactive) 動作は、システムレベルの制約が強制的にロードされていないか、抑止力のあるセマンティクスが不足していることに起因します。AI モデルの知能の欠陥ではありません。**

一般的な根本原因は 3 つです：

1. **グローバルルール (System Prompt) のロードチェーン障害**：
   - 新規会話の作成、作業ディレクトリの切り替え、セッション横断時に、`.agent/rules` 内の必須ルールが現在のコンテキストウィンドウに完全に読み込まれない場合があります。
   - 症状：AI がスムーズにアーキテクチャを分析し、そのまま置換コードブロックを生成したり、直接置換を実行したりします。
2. **防御セマンティクスの柔軟すぎる設定（ソフトガイドライン vs ハード制約）**：
   - 例えば「PLAN してから ACTION を実行してください」とだけ定義した場合、AI はこれを「推奨ベストプラクティス」と解釈し、自己判断でコーディング段階に早期突入します。
   - 「許可なくして、システムはいかなる物理ファイルの変更 / diff の生成も禁止される」と明文化しない限り、防御は機能しません。
3. **プロンプティングバイアス (Prompting Bias)**：
   - ユーザーが「どう修正すべき？」や「修正案をください」といった命令文を使うと、AI の補完本能がトリガーされ、アーキテクチャ設計フェーズをバイパスしてしまいます。

### 標準的な防御策と対処法：

AI の動作を完全に制御・固定するには、以下の強制的な介入を行います：

**1. 戦術レベル（会話ゲート）**：
各バグ報告や新規要件の冒頭に、侵害不可能なコマンドゲートを挿入します：

> **「ハード制約：今回はアーキテクチャ分析（PLAN）と根本原因調査のみを許可します。ファイル上書き、パッチ生成、diff 適用は一切禁止です。私の明示的な 'OK' 返信がない限り、コード実装に進むことはできません。」**

**2. 戦略レベル（基盤ルール強化）**：
`00_core_protocol.md` や `06_documents_first.md` などのトップレベル制約ファイルに、最上位の防御指令を埋め込みます：

> **「ゼロトレランスポリシー (Zero-Tolerance Policy)：ユーザーの明示的な OK 承認を受ける前に、ワークスペースの物理ファイル状態を変更するすべての操作（ソースコード自動修正、パッチファイルエクスポート、diff コマンド適用、git commit 行為を含むがこれらに限定されない）は禁止されます。」**

**最終的な結論**：AI エージェントは優れた操作能力を備えています。解決策は、精密かつゼロトレランスの「判定可能なハード禁止事項」を確立し、各セッション開始時に権限ゲートを実施することにあります。
